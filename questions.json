[
  {
    "text": "Embedded programming is more difficult than classical programming because of the event-based programming model.",
    "code": null,
    "answer": true
  },
  {
    "text": "A defining characteristic of embedded systems is the lack of an interrupt controller.",
    "code": null,
    "answer": false
  },
  {
    "text": "The embedded software crisis refers  to  the  lack  of  correct  code  for  the  increasingnumber of embedded systems.",
    "code": null,
    "answer": true
  },
  {
    "text": "Despite advances in software engineering practices,  as  a  rule  of  thumb,  embeddedsoftware contains 1-10 bugs per million lines of code.",
    "code": null,
    "answer": false
  },
  {
    "text": " An embedded program can be coded as a finite state machine where interrupts triggerstate transitions.",
    "code": null,
    "answer": true
  },
  {
    "text": "An interrupt is a synchronous signal form hardware to indicate the need for processorattention.",
    "code": null,
    "answer": false
  },
  {
    "text": "Besides  Finite  State  Machines  other  models  of  computation  suitable  for  embeddedsystems include Publish/Subscribe and Recursion.",
    "code": null,
    "answer": false
  },
  {
    "text": "Since  disabling  interrupts  increases  interrupt  latency,  several  alternative  methods  havebeen developed for dealing with shared data. The Alternating Buffers method is suited forhanding data from an ISR to a task. The code for toggling theuseBflag should be in the main task (not the ISR) as shown below.",
    "code": "static int tempA[2], tempB[2];\nstatic bool useB = FALSE;\nvoid interrupt readTemp(){\nif (useB){\ntempA[0]= ...;\ntempA[1]= ...;\n}else{\ntempB[0]= ...;\ntempB[1]= ...;\n}\n}\nvoid main(void){\nwhile (TRUE){\nif (useB)\nif (tempB[0]!=tempB[1])\n ...  ;\nelseif (tempA[0]!=tempA[1]) ...  ;\nuseB = !useB;\n}\n}\n",
    "answer": true
  },
  {
    "text": "Using interrupts improves context switch times.",
    "code": null,
    "answer": false
  },
  {
    "text": "An interrupt service routine should restore the context upon exit.",
    "code": null,
    "answer": true
  },
  {
    "text": "To guarantee atomicity task switching must be disabled.",
    "code": null,
    "answer": false
  },
  {
    "text": "A low-priority ISR can be interrupted by a high-priority ISR.",
    "code": null,
    "answer": true
  },
  {
    "text": "The shared data problem can be solved through using semaphores.",
    "code": null,
    "answer": true
  },
  {
    "text": "When a processor is powered up, interrupts are disabled until further notice.",
    "code": null,
    "answer": true
  },
  {
    "text": "Priority inversionrequires a minimum of 3 tasks of different priority and 1 semaphoreto occur.",
    "code": null,
    "answer": true
  },
  {
    "text": "An interrupt vector points to a table with interrupt routines.",
    "code": null,
    "answer": false
  },
  {
    "text": "An interrupt cannotbe serviced faster than the time needed to save the context of coderunning on the processor.",
    "code": null,
    "answer": true
  },
  {
    "text": "Mutual exclusive access can also be accomplished by disabling interrupts, which has theadvantage of faster system response compared to using RTOS primitives like semaphoresand mutexes.",
    "code": null,
    "answer": false
  },
  {
    "text": "The below pseudo code suffers from the shared data problem.",
    "code": "int panic = 0;\nvoid isrbuttons(void) // arrive here if a button is pressed{\nint temp1 = X32PERIPHERALS[PERIPHERALTEMP1];\nint temp2 = X32PERIPHERALS[PERIPHERALTEMP2];\nif (temp1 != temp2){\npanic = 1;\n}\n...\n}\nmain(){\n...\nwhile (!programdone){\n// some lengthy calculations and control commands\nif (panic){\n// shutdown plant\n}\n}\n}\n",
    "answer": false
  },
  {
    "text": "The worst-case latency for servicing an interrupt is a combination of factors, includingthe longest period of time in which interrupts are disabled.",
    "code": null,
    "answer": true
  },
  {
    "text": "Adeadly embracerequires a minimum of 3 tasks and 2 semaphores to occur.",
    "code": null,
    "answer": false
  },
  {
    "text": "Reading the value of the global variablecountis atomic.",
    "code": "static volatile int count;\nmain (){\n...\nint val = count;\n...\n}\n",
    "answer": false
  },
  {
    "text": "Given the following pseudo code, which reads the current values of 4 different buttonsand acts accordingly. The 4 buttons are all mapped to bits 0..3 of the button register. Thebuttons are already debounced. This code is an example of an RRI architecture.",
    "code": "void f1(void){\ndelay(1000);\n}\nvoid f2(void){\ndelay(2000);\n}\nvoid f3(void){\ndelay(3000);\n}\nvoid f4(void){\ndelay(4000);\n}\nvoid main (void){\nwhile (1){\nif (buttons & 0x01)\n f1();\nif (buttons & 0x02 )\n f2();\nif (buttons & 0x04 )\n f3();\nif (buttons & 0x08 )\n f4();\ndelay(1000);\n}\n}\n",
    "answer": false
  },
  {
    "text": "When none of the buttons have been pressed,  the longest time that button #3 must bepressed to activate f3() once is 4 seconds.",
    "code": "void f1(void){\ndelay(1000);\n}\nvoid f2(void){\ndelay(2000);\n}\nvoid f3(void){\ndelay(3000);\n}\nvoid f4(void){\ndelay(4000);\n}\nvoid main (void){\nwhile (1){\nif (buttons & 0x01)\n f1();\nif (buttons & 0x02 )\n f2();\nif (buttons & 0x04 )\n f3();\nif (buttons & 0x08 )\n f4();\ndelay(1000);\n}\n}\n",
    "answer": false
  },
  {
    "text": "When the system is in an arbitrary state, button #1 must be pressed at most 9 seconds toactivate f1().",
    "code": "void f1(void){\ndelay(1000);\n}\nvoid f2(void){\ndelay(2000);\n}\nvoid f3(void){\ndelay(3000);\n}\nvoid f4(void){\ndelay(4000);\n}\nvoid main (void){\nwhile (1){\nif (buttons & 0x01)\n f1();\nif (buttons & 0x02 )\n f2();\nif (buttons & 0x04 )\n f3();\nif (buttons & 0x08 )\n f4();\ndelay(1000);\n}\n}\n",
    "answer": false
  },
  {
    "text": "Given is the following RTOS (pseudo) code with priority T1>T2. This code suffers from a data sharing problem.",
    "code": "void T1(void){\nwhile (1){\nOSPend(sem1);\n // event #1 may unblock any time\nf(1);\nOSTimeDly(1);\n}\n}\nvoid T2(void){\nwhile (1){\nOSPend(sem2);\n // event #2 may unblock any time\nf(-1);\nOSTimeDly(3);\n}\n}\nvoid f(int i){\nOSPend(mutex);\ncounter = counter + i ;\n // modify some global counter\nOSPost(mutex);\n}\n",
    "answer": false
  },
  {
    "text": "If the order of events is #1, #2, #1, #2, #1 and they occur within 10  ms from each other,then the final value of the counter will be increased by 1.",
    "code": "void T1(void){\nwhile (1){\nOSPend(sem1);\n // event #1 may unblock any time\nf(1);\nOSTimeDly(1);\n}\n}\nvoid T2(void){\nwhile (1){\nOSPend(sem2);\n // event #2 may unblock any time\nf(-1);\nOSTimeDly(3);\n}\n}\nvoid f(int i){\nOSPend(mutex);\ncounter = counter + i ;\n // modify some global counter\nOSPost(mutex);\n}\n",
    "answer": true
  },
  {
    "text": "The function f() is reentrant",
    "code": "void T1(void){\nwhile (1){\nOSPend(sem1);\n // event #1 may unblock any time\nf(1);\nOSTimeDly(1);\n}\n}\nvoid T2(void){\nwhile (1){\nOSPend(sem2);\n // event #2 may unblock any time\nf(-1);\nOSTimeDly(3);\n}\n}\nvoid f(int i){\nOSPend(mutex);\ncounter = counter + i ;\n // modify some global counter\nOSPost(mutex);\n}\n",
    "answer": true
  },
  {
    "text": "Theprimaryshortcoming of an FQS architecture is that all tasks have the same priority.",
    "code": null,
    "answer": false
  },
  {
    "text": "An RR architecture doesnotsupport priorities.",
    "code": null,
    "answer": true
  },
  {
    "text": "With an FQS architecture, a task signaled by an ISR is executed immediately after thatISR completes execution.",
    "code": null,
    "answer": false
  },
  {
    "text": "Consider an alarm system that constantly monitors the digital output of several motiondetector sensors in a house.  If a breach is detected then an intermittent alarm sound istriggered.- That alarm system can be implemented with an RR architecture.",
    "code": null,
    "answer": true
  },
  {
    "text": "An RTOS architecture is most robust to code changes.",
    "code": null,
    "answer": true
  },
  {
    "text": "In an RTOS, tasks can be in state BLOCKED, READY or RUNNING.- A task can transition directly from READY to RUNNING.",
    "code": null,
    "answer": true
  },
  {
    "text": "An ISR may change a task’s status from RUNNING to BLOCKED.",
    "code": null,
    "answer": false
  },
  {
    "text": "An ISR can signal a task by operating a semaphore.",
    "code": null,
    "answer": true
  },
  {
    "text": "A reentrant function may use hardware only in an atomic way.",
    "code": null,
    "answer": true
  },
  {
    "text": "A reentrant function maynotreference variables labeledextern.",
    "code": null,
    "answer": false
  },
  {
    "text": "A semaphore used for condition synchronization must be initialized to zero.",
    "code": null,
    "answer": true
  },
  {
    "text": "An ISR mustnotinvoke an RTOS function that may block.",
    "code": null,
    "answer": true
  },
  {
    "text": "A  function  can  be  made  reentrant  by  temporarily  disabling  interrupts,  but  additionalbookkeeping is required as simply enabling interrupts on exit may cause errors.",
    "code": null,
    "answer": true
  },
  {
    "text": "An ISR may call theOSpend()routine, but not theOSpost()routine .",
    "code": null,
    "answer": false
  },
  {
    "text": "When  using  an  RTOS  signaling  between  ISRs  and  tasks  must  be  done  by  callingappropriate RTOS primitives.",
    "code": null,
    "answer": true
  },
  {
    "text": "A program running on an RTOS may create tasks dynamically at runtime.- the program ends as soon as themain()function returns.",
    "code": null,
    "answer": false
  },
  {
    "text": "Theheartbeat timeris a single hardware timer an RTOS is using to verify that the systemis still progressing (i.e. not deadlocked).",
    "code": null,
    "answer": false
  },
  {
    "text": "An RTOS usually provides two types of delay functions: polling-based and timer-based.- polling-based delays are the most accurate.",
    "code": null,
    "answer": true
  },
  {
    "text": "Assume that one system clock tick = 10 ms.- Calling the functionOSTimeDly(5)causes a delay between 40 and 50 ms.",
    "code": null,
    "answer": true
  },
  {
    "text": "Time-slicing should be avoided in an RTOS because it makes the response time of tasksless predictable.",
    "code": null,
    "answer": true
  },
  {
    "text": "A key principle of RTOS-based design is that the separation of concerns, by splitting codeamongst several tasks, improves the overall throughput.",
    "code": null,
    "answer": false
  },
  {
    "text": "Creating and destroying tasks dynamically is somewhat problematic because the RTOSmust disable interrupts for too long.",
    "code": null,
    "answer": false
  },
  {
    "text": "Tasks  in  an  RTOS  are  often  structured  as  state  machines  with  states  stored  in  privatevariables and ISRs advancing the state machine.",
    "code": null,
    "answer": false
  },
  {
    "text": "It is recommended to use just the minimum necessary functionality from an RTOS.",
    "code": null,
    "answer": true
  },
  {
    "text": "Tasks can share the same stack as mutual exclusion allows only one task to execute acritical section.",
    "code": null,
    "answer": false
  },
  {
    "text": "A logic analyzer is preferred to an in-circuit emulator because it can monitor the internalmemory bus of (most) modern micro controllers.",
    "code": null,
    "answer": false
  },
  {
    "text": "When developing code for an embedded system, the software can de structured into HW-dependent and HW-independent code.- Doing so makes debugging HW-independent code feasible on the target platform",
    "code": null,
    "answer": false
  },
  {
    "text": "Debugging through scripting test scenarios cannotbe used to test HW-dependent code.",
    "code": null,
    "answer": true
  },
  {
    "text": "A large study of outdoor sensor-network deployments [Beutel:2009] has shown that thetwo most underestimated problems have been the water-proof packaging of the sensornodes and the provision of a reliable base station.",
    "code": null,
    "answer": true
  },
  {
    "text": "When debugging code for a distributed sensor network, collecting the (debug) output ofthe nodes can be arranged in different ways.-onlinesniffing requires logging facilities on the sensor nodes themselves.",
    "code": null,
    "answer": false
  },
  {
    "text": "Given is the following RTOS (pseudo) code.   T1 has the highest priority,  the time forputsand context switching is negligible. The display shows the sequence 1 2 1 2 1 2 1 2 1 2 ...",
    "code": "void T1(void){\nwhile (1){\nputs(\"1 \");\nOSTimeDly(10);\n}\n}\nvoid T2(void){\nwhile (1){\nputs(\"2 \");\nOSTimeDly(10);\n}\n}\n",
    "answer": true
  },
  {
    "text": "When we replace theOSTimeDly(10)call with adelay(10)call, the ouput of theprint statements will be displayed in a random order.",
    "code": "void T1(void){\nwhile (1){\nputs(\"1 \");\nOSTimeDly(10);\n}\n}\nvoid T2(void){\nwhile (1){\nputs(\"2 \");\nOSTimeDly(10);\n}\n}\n",
    "answer": false
  },
  {
    "text": "Embedded programming is more difficult than “classical” programming because of thethread-based programming model.",
    "code": null,
    "answer": false
  },
  {
    "text": "TheEmbedded software  crisisrefers to  the decrease in the  number of manufacturedembedded systems.",
    "code": null,
    "answer": false
  },
  {
    "text": "A  defining  characteristic  of  embedded  systems  is  the  restricted  memory  size  andprocessing power.",
    "code": null,
    "answer": true
  },
  {
    "text": "Besides  Finite  State  Machines  other  models  of  computation  suitable  for  embeddedsystems include Publish/Subscribe and Discrete Events",
    "code": null,
    "answer": true
  },
  {
    "text": "An interrupt is an asynchronous signal form hardware to indicate the need for processorattention.",
    "code": null,
    "answer": true
  },
  {
    "text": "An embedded program can be coded as a finite state machine; the number of incomingtransitions (arcs) into a state S must equal the number of outgoing transitions (arcs).",
    "code": null,
    "answer": false
  },
  {
    "text": "VHDL is an ideal programming language for embedded systems as its synchronous modelof computation supports multi-tasking at the hardware level.",
    "code": null,
    "answer": false
  },
  {
    "text": "Using interrupts improves system response time.",
    "code": null,
    "answer": true
  },
  {
    "text": "An interrupt service routine should save the context upon exit.",
    "code": null,
    "answer": false
  },
  {
    "text": "To guarantee atomicity critical sections must be disabled.",
    "code": null,
    "answer": false
  },
  {
    "text": "The above pseudo code suffers from the shared-data problem.",
    "code": "int temp1, temp2;void isrbuttons(void) // arrive here if a button is pressed{temp1 = X32PERIPHERALS[PERIPHERALTEMP1];temp2 = X32PERIPHERALS[PERIPHERALTEMP2];...}main(){...while (!programdone){X32display = ((temp1 & 0xff) << 8) | (temp2 & 0xff);if (temp1 != temp2){// shutdown plant}}}",
    "answer": true
  },
  {
    "text": "An interrupt vector table contains the addresses of the interrupt service routines.",
    "code": null,
    "answer": true
  },
  {
    "text": "An interrupt cannotbe serviced faster than the execution time of the shortest task in thesystem.",
    "code": null,
    "answer": false
  },
  {
    "text": "The worst-case latency for servicing an interrupt is a combination of factors, includingthe time taken for higher priority interrupts.",
    "code": null,
    "answer": true
  },
  {
    "text": "Priority inversionrequires a minimum of 2 tasks of different priority and 1 semaphoreto occur.",
    "code": null,
    "answer": false
  },
  {
    "text": "Adeadly embracerequires a minimum of 2 tasks and 2 semaphores to occur.",
    "code": null,
    "answer": true
  },
  {
    "text": "Given the following pseudo code, which reads the current values of 4 different buttonsand acts accordingly. The 4 buttons are all mapped to bits 0..3 of the button register. Thebuttons are already debounced. This code is an example of an RR architecture.",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void f4(void){delay(4000);}void main (void){while (1){if (buttons & 0x01) f1();if (buttons & 0x02 ) f2();if (buttons & 0x04 ) f3();if (buttons & 0x08 ) f4();delay(1000);}}",
    "answer": true
  },
  {
    "text": "When none of the buttons have been pressed,  the longest time that button #3 must bepressed to activate f3() once is 1 second.",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void f4(void){delay(4000);}void main (void){while (1){if (buttons & 0x01) f1();if (buttons & 0x02 ) f2();if (buttons & 0x04 ) f3();if (buttons & 0x08 ) f4();delay(1000);}}",
    "answer": true
  },
  {
    "text": "When the system is in an arbitrary state, button #1 must be pressed at most 5 seconds toactivate f1().",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void f4(void){delay(4000);}void main (void){while (1){if (buttons & 0x01) f1();if (buttons & 0x02 ) f2();if (buttons & 0x04 ) f3();if (buttons & 0x08 ) f4();delay(1000);}}",
    "answer": false
  },
  {
    "text": "The shared-data problem can be solved through using mutexes.",
    "code": null,
    "answer": true
  },
  {
    "text": "When a processor in an embedded system is powered up, interrupts are enabled to meetresponse-time requirements.",
    "code": null,
    "answer": false
  },
  {
    "text": "Writing to the global variablecountis atomic.",
    "code": "static volatile int count;main (){...count = 666;...}",
    "answer": false
  },
  {
    "text": "On 8-bit processors the number of interrupt priorities is limited to 256 (28).",
    "code": null,
    "answer": false
  },
  {
    "text": "Theprimaryshortcoming of an RRI architecture is that critical sections must be used.",
    "code": null,
    "answer": false
  },
  {
    "text": "An RRI architecture supports priority-based task scheduling.",
    "code": null,
    "answer": false
  },
  {
    "text": "The response time to an external event in an FQS architecture depends on the longest taskin the system.",
    "code": null,
    "answer": true
  },
  {
    "text": "With  an  RRI  architecture,  a  task  associated  with  a  high-priority  interrupt  is  executedimmediately after that ISR completes execution.",
    "code": null,
    "answer": false
  },
  {
    "text": "Consider an alarm system that constantly monitors the digital output of several motiondetector sensors in a house.  If a breach is detected then an intermittent alarm sound istriggered.- To guarantee a minimum response time an RRI or more advanced architecture must beused.",
    "code": null,
    "answer": false
  },
  {
    "text": "A FQS architecture reduces to an RRI architecture when tasks are serviced in FIFO order.",
    "code": null,
    "answer": false
  },
  {
    "text": "In an RTOS, tasks can be in state BLOCKED, READY or RUNNING.- a task starts in the state RUNNING.",
    "code": null,
    "answer": true
  },
  {
    "text": "Semaphores can be used for signaling between tasks.",
    "code": null,
    "answer": true
  },
  {
    "text": "An ISR may change a task’s status from RUNNING to READY.",
    "code": null,
    "answer": false
  },
  {
    "text": "A semaphore used for guaranteeing mutual exclusive access to shared resources must beinitialized to 1.",
    "code": null,
    "answer": true
  },
  {
    "text": "A function can be made reentrant by means of a critical section, but then it may no longerbe called by an ISR.",
    "code": null,
    "answer": true
  },
  {
    "text": "A program running on an RTOS may create tasks dynamically at runtime.- new tasks may only be spawned by themain()function.",
    "code": null,
    "answer": false
  },
  {
    "text": "Context  switching  from  one  task  to  another  is  only  slightly  more  expensive  than  anordinary function call as the difference is that the stack pointer must be adjusted as well.",
    "code": null,
    "answer": false
  },
  {
    "text": "An ISR may call theOSpost()routine, but not theOSpend()routine.",
    "code": null,
    "answer": false
  },
  {
    "text": "When upgrading to an RTOS, signaling between ISRs and tasks may still be done throughflags residing in global memory.",
    "code": null,
    "answer": false
  },
  {
    "text": "In the implementation of theOSPend()primitive, the RTOS first switches the state ofthe current task to BLOCKED, and then looks for a task in the READY queue.- if the READY queue is empty the program is deadlocked and may be aborted.",
    "code": null,
    "answer": false
  },
  {
    "text": "Local variables can be used at will without creating a shared-data problem.",
    "code": null,
    "answer": true
  },
  {
    "text": "Functionf()that disables/enables interrupts on entry/exit fails to address the shared-dataproblem when calling itself recursively.",
    "code": "int f (int x){disableint();!!  touch some global variables!!  do some processing!!  call some functionsenableint();}",
    "answer": false
  },
  {
    "text": "The ’alternating buffers’ technique addresses the shared-data problem by copying the datafrom the in- to the out-buffer instead of passing a pointer.",
    "code": null,
    "answer": false
  },
  {
    "text": "An RTOS usually provides two types of delay functions: polling-based and timer-based.- timer-based delays are the most accurate.",
    "code": null,
    "answer": false
  },
  {
    "text": "Assume that one system clock tick = 10 ms.- Calling the functionOSTimeDly(4)causes a delay of exactly 40 ms.",
    "code": null,
    "answer": false
  },
  {
    "text": "Theheartbeat timeris a single hardware timer an RTOS is using as base for all timings.",
    "code": null,
    "answer": true
  },
  {
    "text": "When using an RTOS thedelay()function may not be used because the hardware timeris used to implement time slicing.",
    "code": null,
    "answer": false
  },
  {
    "text": "To address the shared-data problem, many RTOSs provide communication primitives likequeues, mailboxes, and pipes.- a common pitfall is that they allow pointers to be passed from one task to another.",
    "code": null,
    "answer": true
  },
  {
    "text": "A key principle of RTOS-based design is that short interrupt routines are needed for aresponsive system",
    "code": null,
    "answer": true
  },
  {
    "text": "Aborting tasks is nontrivial because a task may hold resources (e.g., a semaphore) whenbeing destroyed.",
    "code": null,
    "answer": true
  },
  {
    "text": "Time-slicing  should  be  avoided  in  an  RTOS  because  it  extends  thedeadly  embraceproblem to tasks of equal priority.",
    "code": null,
    "answer": false
  },
  {
    "text": "In an RTOS each task requires its own stack space.",
    "code": null,
    "answer": true
  },
  {
    "text": "Printing from an ISR is considered bad practice as the driver resides in the RTOS.",
    "code": null,
    "answer": false
  },
  {
    "text": "Time slicing between ISRs is common practice in embedded systems.",
    "code": null,
    "answer": false
  },
  {
    "text": "A logic analyzer is preferred to an in-circuit emulator because it can be used with any typeof processor.",
    "code": null,
    "answer": true
  },
  {
    "text": "When developing code for an embedded system, the software can de structured into HW-dependent and HW-independent code.- Doing so makes debugging HW-independent code feasible on the host platform",
    "code": null,
    "answer": true
  },
  {
    "text": "Debugging through scripting test scenarios has limited use as only one interrupt can betriggered at the exact same time.",
    "code": null,
    "answer": false
  },
  {
    "text": "When debugging code for a distributed sensor network, collecting the (debug) output ofthe nodes can be arranged in different ways [Beutel:2009].-offlinesniffing requires logging facilities on the sniffer nodes.",
    "code": null,
    "answer": true
  },
  {
    "text": "A large study of outdoor sensor-network deployments has shown that the most underesti-mated problem has been the water-proof packaging of the base station.",
    "code": null,
    "answer": false
  },
  {
    "text": "Given is the following RTOS (pseudo) code.   T1 has the highest priority,  the time forputsand context switching is negligible: The display shows the sequence \"2 1 2 1 2 1 2 1 2 ...\"",
    "code": "void T1(void){while (1){puts(\"1 \");OSTimeDly(10);}}void T2(void){while (1){puts(\"2 \");OSTimeDly(10);}}",
    "answer": false
  },
  {
    "text": "When we replace theOSTimeDly(10)call with adelay(10)call, the display willshow the sequence ”1 1 1 1 1 1 1 1 1 1 ...”",
    "code": "void T1(void){while (1){puts(\"1 \");OSTimeDly(10);}}void T2(void){while (1){puts(\"2 \");OSTimeDly(10);}}",
    "answer": true
  },
  {
    "text": "Embedded programming is more difficult than “classical” programming because of thelack of support for recursion.",
    "code": null,
    "answer": false
  },
  {
    "text": "A defining characteristic of embedded systems is the need for predictable timing behavior.",
    "code": null,
    "answer": true
  },
  {
    "text": "TheEmbedded software crisisrefers to the “year 2000” bug.",
    "code": null,
    "answer": false
  },
  {
    "text": "Finite State Machines can be coded in VHDL.- An advantage of doing so is that it results in a fast and predictable process executing ondedicated hardware.",
    "code": null,
    "answer": true
  },
  {
    "text": "Despite  advances  in  software  engineering  practices,  as  a  rule  of  thumb,  embeddedsoftware contains 1-10 bugs per thousand lines of code.",
    "code": null,
    "answer": true
  },
  {
    "text": "The Underground Tank Monitoring System is a classic example of an embedded system inthat it involves input (sensors/buttons), output (display/printer) and real-time constraints.",
    "code": null,
    "answer": true
  },
  {
    "text": "Because embedded software engages the physical world, it has to embrace time and othernon-functional properties, which requires a view that is significantly different from theprevailing abstractions in computation.",
    "code": null,
    "answer": true
  },
  {
    "text": "An interrupt is a synchronous signal from hardware to indicate the need for processorattention.",
    "code": null,
    "answer": false
  },
  {
    "text": "The  C  language  is  centered  around  theintdata  type  that  represents  the  canonicalmachine word.- As such the size of anintis architecture dependent.",
    "code": null,
    "answer": true
  },
  {
    "text": "The  definition  above  declaresresolveas  a  pointer  to  a  function  that  takes  twoarguments of typevoid*and returns a void pointer as result.",
    "code": "typedef void*(*resolve)(void*old, void*new);",
    "answer": true
  },
  {
    "text": "GDB is programming tool that aids memory debugging by executing a program in a safeenvironment.",
    "code": null,
    "answer": false
  },
  {
    "text": "Finite State Machines can be coded in a number of ways in C.- In the table-based solution, every state is encoded as a separate function.",
    "code": null,
    "answer": false
  },
  {
    "text": "The below loop drives the FSM until all characters from the standard input have been processed.",
    "code": "int main(void){int c;statefp state = start;while((c = getchar()) != EOF){state = (statefp) (*state)(c);}return 0;}",
    "answer": true
  },
  {
    "text": "Specifying the type ofstatefpis difficult in C because it is recursive and types cannotbe referenced before being fully defined.",
    "code": "int main(void){int c;statefp state = start;while((c = getchar()) != EOF){state = (statefp) (*state)(c);}return 0;}",
    "answer": true
  },
  {
    "text": "Using interrupts improves task response time.",
    "code": null,
    "answer": false
  },
  {
    "text": "An interrupt service routine should save the context upon entrance.",
    "code": null,
    "answer": true
  },
  {
    "text": "A low-priority ISR can be interrupted by a high-priority task.",
    "code": null,
    "answer": false
  },
  {
    "text": "Since  disabling  interrupts  increases  interrupt  latency,  several  alternative  methods  havebeen developed for dealing with shared data. The Alternating Buffers method is suited forhanding data from an ISR to a task. The above code with toggling theuseAflag in the ISR is correct.",
    "code": "static int tempA[2], tempB[2];static bool useA = TRUE;void interrupt readTemp(){if (useA){tempA[0]= ...;tempA[1]= ...;}else{tempB[0]= ...;tempB[1]= ...;}useA = !useA;}void main(void){while (TRUE){if (useA)if (tempB[0]!=tempB[1]) ...  ;elseif (tempA[0]!=tempA[1]) ...  ;}}",
    "answer": false
  },
  {
    "text": "An interrupt vector contains the address of an ISR.",
    "code": null,
    "answer": true
  },
  {
    "text": "Disabling  interrupts  guarantees  atomicity  of  the  code  until  the  interrupts  are  enabledagain.",
    "code": null,
    "answer": true
  },
  {
    "text": "Priority inversionoccurs when thevolatileandstatickeywords are wrongly usedinside a task or interrupt.",
    "code": null,
    "answer": false
  },
  {
    "text": "The worst-case latency for servicing an interrupt is a combination of factors, includingthe time taken for higher priority tasks.",
    "code": null,
    "answer": false
  },
  {
    "text": "The number of interrupts is limited by the number of GPIO pins on the processor.",
    "code": null,
    "answer": false
  },
  {
    "text": "Mutual exclusive access can also be accomplished by disabling interrupts, which has theadvantage of faster context switching compared to using RTOS primitives like semaphoresand mutexes.",
    "code": null,
    "answer": false
  },
  {
    "text": "The shared-data problem can be solved through using thevolatilekeyword.",
    "code": null,
    "answer": false
  },
  {
    "text": "Given the following pseudo code, which reads the current values of 4 different buttonsand acts accordingly. The 4 buttons are all mapped to bits 0..3 of the button register. Thebuttons are already debounced. This code is an example of an RRI architecture.",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void f4(void){delay(4000);}void main (void){while (1){if (buttons & 0x01) f1();if (buttons & 0x02 ) f2();if (buttons & 0x04 ) f3();if (buttons & 0x08 ) f4();delay(1000);}}",
    "answer": false
  },
  {
    "text": "When the system is in an arbitrary state, button #1 must be pressed at most 10 seconds toactivate f1().",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void f4(void){delay(4000);}void main (void){while (1){if (buttons & 0x01) f1();if (buttons & 0x02 ) f2();if (buttons & 0x04 ) f3();if (buttons & 0x08 ) f4();delay(1000);}}",
    "answer": true
  },
  {
    "text": "Theprimaryshortcoming of an RRI architecture is that all tasks have the same priority.",
    "code": null,
    "answer": true
  },
  {
    "text": "An RTOS architecture supports priority-based task scheduling.",
    "code": null,
    "answer": true
  },
  {
    "text": "An RR architecture is robust to code changes.",
    "code": null,
    "answer": false
  },
  {
    "text": "The response time to an external event in an FQS architecture is deterministic and dependssolely on the length of the ISR.",
    "code": null,
    "answer": false
  },
  {
    "text": "Consider an alarm system that constantly monitors the digital output of several motiondetector sensors in a house.  If a breach is detected then an intermittent alarm sound istriggered.- That alarm system can be implemented with an RR architecture.",
    "code": null,
    "answer": true
  },
  {
    "text": "A FQS architecture reduces to an RRI architecture when tasks are serviced in LIFO order.",
    "code": null,
    "answer": false
  },
  {
    "text": "In an RTOS, tasks can be in state BLOCKED, READY or RUNNING.- a task starts in the state READY.",
    "code": null,
    "answer": true
  },
  {
    "text": "A function can be made reentrant by temporarily disabling interrupts, but then it may nolonger be called by an ISR.",
    "code": null,
    "answer": true
  },
  {
    "text": "A task can signal an ISR by operating a semaphore.",
    "code": null,
    "answer": false
  },
  {
    "text": "A reentrant function may use variables only in an atomic way.",
    "code": null,
    "answer": false
  },
  {
    "text": "An ISR may call neither theOSpost()routine, nor theOSpend()routine.",
    "code": null,
    "answer": false
  },
  {
    "text": "A semaphore used for guaranteeing mutual exclusive access to shared resources must beinitialized to the number of tasks involved.",
    "code": null,
    "answer": false
  },
  {
    "text": "Even a local variable can introduce a shared data problem when its address escapes thedefining function, for example, by storing the address in a global datastructure.",
    "code": null,
    "answer": true
  },
  {
    "text": "A program running on an RTOS may create tasks dynamically at runtime.- the program ends as soon as the last task terminates.",
    "code": null,
    "answer": false
  },
  {
    "text": "Given is the following RTOS (pseudo) code with priority T1>T2. This code suffers from a data sharing problem.",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);}}void f(int i){delay(10); // do some computationcounter = counter + i ; // modify some global counterprintf(\"%d\\n\", counter) ; // print result}",
    "answer": true
  },
  {
    "text": "Ifcountis set to 15 when event 2 occurs, and event 1 follows 3 ms later, then the firstvalue printed is 14.",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);}}void f(int i){delay(10); // do some computationcounter = counter + i ; // modify some global counterprintf(\"%d\\n\", counter) ; // print result}",
    "answer": false
  },
  {
    "text": "If the call todelayis replaced withOSTimeDlythe output will be different.",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);}}void f(int i){delay(10); // do some computationcounter = counter + i ; // modify some global counterprintf(\"%d\\n\", counter) ; // print result}",
    "answer": true
  },
  {
    "text": "An RTOS usually provides two types of delay functions: polling-based and timer-based.- polling-based delays are more efficient as other tasks can run while the caller is waitingfor the specified time to pass.",
    "code": null,
    "answer": false
  },
  {
    "text": "Theheartbeat timeris a single hardware timer an RTOS is using as base for all timings.",
    "code": null,
    "answer": true
  },
  {
    "text": "Assume that one system clock tick = 10 ms.- Calling the functionOSTimeDly(6)causes a delay between 60 and 70 ms.",
    "code": null,
    "answer": false
  },
  {
    "text": "To address the shared-data problem, many RTOSs provide communication primitives likequeues, mailboxes, and pipes.- the basic read/write operations on these primitives are atomic.",
    "code": null,
    "answer": false
  },
  {
    "text": "As  the  RTOSs  is  aware  of  which  task  is  using  which  semaphore,  deadlock  can  beprevented by delaying theOSPendoperation of the last runnable task.",
    "code": null,
    "answer": false
  },
  {
    "text": "Tasks  in  an  RTOS  are  often  structured  as  state  machines  with  states  stored  in  privatevariables and messages in their queues acting as events.",
    "code": null,
    "answer": true
  },
  {
    "text": "The memory footprint of a program grows linearly with the number of tasks.",
    "code": null,
    "answer": true
  },
  {
    "text": "Printing  from  an  ISR  is  to  be  avoided  when  the  RTOS  does  not  provide  a  reentrantprimitive to do so.",
    "code": null,
    "answer": true
  },
  {
    "text": "A key principle of RTOS-based design is that the separation of concerns, by splitting codeamongst several tasks, improves the overall throughput.",
    "code": null,
    "answer": false
  },
  {
    "text": "Time  slicing  between  tasks  of  equal  priority  is  to  be  avoided  as  the  response  time  ofindividual tasks is comprised.",
    "code": null,
    "answer": true
  },
  {
    "text": "It is recommended to use just the minimum necessary functionality from an RTOS.",
    "code": null,
    "answer": true
  },
  {
    "text": "A logic analyzer is preferred to an in-circuit emulator because it is easier to use.",
    "code": null,
    "answer": true
  },
  {
    "text": "When developing code for an embedded system, the software can de structured into HW-dependent and HW-independent code.- Doing so makes debugging HW-independent code feasible on the target platform",
    "code": null,
    "answer": false
  },
  {
    "text": "Debugging  through  scripting  test  scenarios  is  difficult  when  the  target  platform  isunavailable.",
    "code": null,
    "answer": false
  },
  {
    "text": "When debugging code for a distributed sensor network, collecting the (debug) output ofthe nodes can be arranged in different ways [Beutel:2009].- Awirelesstestbed requires physical instrumentation (i.e. wiring) of the sensor node.",
    "code": null,
    "answer": true
  },
  {
    "text": "A large study of outdoor sensor-network deployments has shown that the most underesti-mated problem has been the water-proof packaging of the base station.",
    "code": null,
    "answer": false
  },
  {
    "text": "Embedded programming is more difficult than “classical” programming because of thehigher level of abstraction involved.",
    "code": null,
    "answer": false
  },
  {
    "text": "A defining characteristic of embedded systems is the restricted, or complete lack, of a userinterface.",
    "code": null,
    "answer": true
  },
  {
    "text": "Despite  advances  in  software  engineering  practices,  as  a  rule  of  thumb,  embeddedsoftware contains 1-10 bugs per million lines of code.",
    "code": null,
    "answer": false
  },
  {
    "text": "An embedded program can be coded as a finite state machine where all state transitionsare triggered by user actions.",
    "code": null,
    "answer": false
  },
  {
    "text": "Finite State Machines can be coded in VHDL.- An advantage of doing so is that it results in lower interrupt latency as less context (e.g.,registers) need to be saved and restored.",
    "code": null,
    "answer": false
  },
  {
    "text": "A software interrupt is an asynchronous signal to indicate the need for a change in theexecution flow.",
    "code": null,
    "answer": false
  },
  {
    "text": "Besides  Finite  State  Machines  other  models  of  computation  suitable  for  embeddedsystems include Symbolic Execution and Discrete Events.",
    "code": null,
    "answer": false
  },
  {
    "text": "The definition above declares the prototype of the functionresolve, which takes twoarguments of typevoid*and returns a void pointer as result.",
    "code": "typedef void*resolve(void*old, void*new);",
    "answer": true
  },
  {
    "text": "Valgrind is programming tool that aids memory debugging.- it does so by executing a program in a safe environment.",
    "code": null,
    "answer": true
  },
  {
    "text": "The C language is centered around theintdata type, which is defined to hold integralnumbers of at least 16 bits.",
    "code": null,
    "answer": true
  },
  {
    "text": "Finite State Machines can be coded in a number of ways in C.- In the table-based solution, every transition (arc) is encoded as a separate function.",
    "code": null,
    "answer": false
  },
  {
    "text": "The above driver loop for a FSM is interrupt based.",
    "code": "int main(void){int c;statefp state = before;while((c = getchar()) != EOF){state = (statefp) (*state)(c);}return 0;}",
    "answer": false
  },
  {
    "text": "Specifying the type ofstatefpis difficult in C because forward declarations are notsupported for function types.",
    "code": "int main(void){int c;statefp state = before;while((c = getchar()) != EOF){state = (statefp) (*state)(c);}return 0;}",
    "answer": false
  },
  {
    "text": "Using interrupts improves system response time.",
    "code": null,
    "answer": true
  },
  {
    "text": "An interrupt service routine should restore the context upon exit.",
    "code": null,
    "answer": true
  },
  {
    "text": "To guarantee atomicity interrupts must be disabled.",
    "code": null,
    "answer": false
  },
  {
    "text": "An ISR cannotbe interrupted by another ISR.",
    "code": null,
    "answer": false
  },
  {
    "text": "Despite disabling interrupts the above pseudo code fails to solve the shared-data problem.",
    "code": "static int iSeconds, iMinutes;void interrupt vUpdateTime(void){++iSeconds;if (iSeconds>=60){iSeconds=0;++iMinutes;}}long lSeconds(void){disable();return (iMinutes*60+iSeconds);enable();}",
    "answer": true
  },
  {
    "text": "By structuring a program as a collection of tasks the data sharing problem is resolved.",
    "code": null,
    "answer": false
  },
  {
    "text": "An interrupt vector table contains the code of the interrupt service routines.",
    "code": null,
    "answer": false
  },
  {
    "text": "The worst-case latency for servicing an interrupt is a combination of factors, includingthe time taken for higher priority tasks.",
    "code": null,
    "answer": false
  },
  {
    "text": "Given the following pseudo code, which reads the current values of 3 different buttonsand acts accordingly. The 3 buttons are all mapped to bits 0..2 of the button register. Thebuttons are already debounced. Given the following pseudo code, which reads the current values of 3 different buttonsand acts accordingly. The 3 buttons are all mapped to bits 0..2 of the button register. Thebuttons are already debounced.",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void main (void){while (1){if (buttons & 0x01) f1();delay(1000);if (buttons & 0x02 ) f2();delay(1000);if (buttons & 0x04 ) f3();}}",
    "answer": true
  },
  {
    "text": "When none of the buttons have been pressed,  the longest time that button #2 must bepressed to activate f2() once is 1 second.",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void main (void){while (1){if (buttons & 0x01) f1();delay(1000);if (buttons & 0x02 ) f2();delay(1000);if (buttons & 0x04 ) f3();}}",
    "answer": false
  },
  {
    "text": "When the system is in an arbitrary state, button #1 must be pressed at most 7 seconds toactivate f1().",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void main (void){while (1){if (buttons & 0x01) f1();delay(1000);if (buttons & 0x02 ) f2();delay(1000);if (buttons & 0x04 ) f3();}}",
    "answer": true
  },
  {
    "text": "Priority inversionrequires a minimum of 3 tasks of different priority and 3 semaphoresto occur.",
    "code": null,
    "answer": false
  },
  {
    "text": "Adeadly embracerequires a minimum of 2 tasks and 1 semaphore to occur.",
    "code": null,
    "answer": false
  },
  {
    "text": "Shared variables markedvolatileguarantee atomic access.",
    "code": null,
    "answer": false
  },
  {
    "text": "With an RR architecture, the handling of an I/O device may need to wait until all otherdevices have been served.",
    "code": null,
    "answer": true
  },
  {
    "text": "An RRI architecture supports priority-based ISRs.",
    "code": null,
    "answer": false
  },
  {
    "text": "The response time to an external event in an FQS architecture depends on the longest taskin the system.",
    "code": null,
    "answer": true
  },
  {
    "text": "Consider an alarm system that constantly monitors the digital output of several motiondetector sensors in a house.  If a breach is detected then an intermittent alarm sound istriggered.- To guarantee a minimum response time an FQS architecture must be used.",
    "code": null,
    "answer": false
  },
  {
    "text": "Theprimaryshortcoming of an RRI architecture is that critical sections must be used.",
    "code": null,
    "answer": false
  },
  {
    "text": "An FQS architecture has a smaller memory footprint than an RTOS as it needs only onestack.",
    "code": null,
    "answer": true
  },
  {
    "text": "In an RTOS, tasks can be in state BLOCKED, READY or RUNNING.- A task can transition directly from BLOCKED to READY.",
    "code": null,
    "answer": true
  },
  {
    "text": "Semaphores can be used for signaling between ISRs.",
    "code": null,
    "answer": false
  },
  {
    "text": "A reentrant function maynotreference variables labeledextern.",
    "code": null,
    "answer": false
  },
  {
    "text": "A semaphore used for guaranteeing mutual exclusive access to shared resources must beinitialized to 1.",
    "code": null,
    "answer": true
  },
  {
    "text": "A high-priority task mustnotinvoke an RTOS function that may block.",
    "code": null,
    "answer": false
  },
  {
    "text": "An  ISR  may  call  theOSpost()routine,  provided  that  the  RTOS  “knows”  that  theinvocation is by an ISR and not by an ordinary task.",
    "code": null,
    "answer": true
  },
  {
    "text": "The ’alternating buffers’ technique addresses the shared-data problem by copying the datafrom the in- to the out-buffer instead of passing a pointer.",
    "code": null,
    "answer": false
  },
  {
    "text": "Functionf()disables/enables interrupts to address the shared-data problem.- However, whenf()calls itself recursively, it is no longer reentrant.",
    "code": "int f (int x){disableint();!!  read some global variables!!  do some processing, call some functions!!  write some global variablesenableint();}",
    "answer": true
  },
  {
    "text": "Given is the following RTOS (pseudo) code with priority T1>T2. The function f() is reentrant",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);}}void f(int i){delay(10); // do some computationcounter = counter + i ; // modify some global counterprintf(\"%d\\n\", counter) ; // print result}",
    "answer": false
  },
  {
    "text": "Ifcountis set to 15 when event 2 occurs, and event 1 follows 3 ms later, then the firstvalue printed is 16.",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);}}void f(int i){delay(10); // do some computationcounter = counter + i ; // modify some global counterprintf(\"%d\\n\", counter) ; // print result}",
    "answer": true
  },
  {
    "text": "If  the  call  todelayis  replaced  withOSTimeDlythe  order  of  the  print  statementsdepends on wether or not a timer interrupt appeared in between the two events.",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);}}void f(int i){delay(10); // do some computationcounter = counter + i ; // modify some global counterprintf(\"%d\\n\", counter) ; // print result}",
    "answer": true
  },
  {
    "text": "An RTOS usually provides two types of delay functions: polling-based and timer-based.- timer-based delays are more efficient as other tasks can run while the caller is waitingfor the specified time to pass.",
    "code": "!",
    "answer": true
  },
  {
    "text": "Theheartbeat timeris a single hardware timer an RTOS is using to verify that the systemis still progressing (i.e. not deadlocked).",
    "code": null,
    "answer": false
  },
  {
    "text": "Assume that one system clock tick = 10 ms.- Calling the functionOSTimeDly(6)causes a delay between 65 and 75 ms.",
    "code": null,
    "answer": false
  },
  {
    "text": "To address the shared-data problem, many RTOSs provide communication primitives likequeues, mailboxes, and pipes.- a common pitfall is that they allow pointers to be passed from one task to another.",
    "code": null,
    "answer": true
  },
  {
    "text": "Even when an RTOSs is aware of which task is using which semaphore, it cannot preventdeadlock.",
    "code": null,
    "answer": true
  },
  {
    "text": "Time-slicing should be avoided in an RTOS because it makes the response time of tasksless predictable.",
    "code": null,
    "answer": true
  },
  {
    "text": "The minimal memory footprint of a program grows linearly with the number of tasks.",
    "code": null,
    "answer": true
  },
  {
    "text": "Printing from an ISR is to be avoided except when the RTOS provides a reentrant primitiveto do so.",
    "code": null,
    "answer": true
  },
  {
    "text": "Time slicing between tasks of equal priority is common practice in embedded systems.",
    "code": null,
    "answer": false
  },
  {
    "text": "Aborting tasks is nontrivial because a task may hold resources (e.g., a semaphore) whenbeing destroyed.",
    "code": null,
    "answer": true
  },
  {
    "text": "Tasks should have different priorities to avoid fairness issues imposed by the RTOS.",
    "code": null,
    "answer": false
  },
  {
    "text": "Code coverage tools help in thorough testing.- a 100% coverage implies a bug-free program.",
    "code": null,
    "answer": false
  },
  {
    "text": "A logic analyzer is preferred to an in-circuit emulator because it is easier to install; not allsignals need to be connected.",
    "code": null,
    "answer": true
  },
  {
    "text": "Debugging through scripting test scenarios can only be used to test HW-independent code.",
    "code": null,
    "answer": true
  },
  {
    "text": "A large study of outdoor sensor-network deployments [Beutel:2009] has shown that thetwo most underestimated problems have been the water-proof packaging of the sensornodes and the provision of a reliable base station.",
    "code": null,
    "answer": true
  },
  {
    "text": "When debugging code for a distributed sensor network, collecting the (debug) output ofthe nodes can be arranged in different ways.- Awirelesstestbed requiresnophysical instrumentation (i.e. wiring) of the sensor node.",
    "code": null,
    "answer": false
  },
  {
    "text": "A defining characteristic of embedded systems is the need for large volumes of scale.",
    "code": null,
    "answer": false
  },
  {
    "text": "The Underground Tank Monitoring System is a classic example of an embedded system inthat it involves input (sensors/buttons), output (display/printer) and real-time constraints.",
    "code": null,
    "answer": true
  },
  {
    "text": "Because embedded software engages the physical world, it has to embrace time and othernon-functional properties, which requires a view that is significantly different from theprevailing abstractions in computation.",
    "code": null,
    "answer": true
  },
  {
    "text": "Embedded programming is more difficult than “classical” programming because of theevent-based programming model.",
    "code": null,
    "answer": true
  },
  {
    "text": "Interrupts cannot only be generated by hardware, but also by software.- A software interrupt is a synchronous signal to indicate the need for a change in theexecution flow.",
    "code": null,
    "answer": true
  },
  {
    "text": "An embedded program can be coded as a finite state machine.- When for every state S the number of incoming transitions (arcs) equals the number ofoutgoing transitions (arcs), the code is free of deadlocks.",
    "code": null,
    "answer": false
  },
  {
    "text": "Finite State Machines can be coded in VHDL.- An advantage of doing so is that it results in a fast and predictable process executing ondedicated hardware.",
    "code": null,
    "answer": true
  },
  {
    "text": "The C language is centered around theintdata type,  which is defined to hold 32-bitintegral numbers.",
    "code": null,
    "answer": false
  },
  {
    "text": "Arrays in C are basicallysyntactic sugarfor pointers, and notation may be mixed freely. The below assert will hold.",
    "code": "int array[100];int*ptr = array;ptr = 17;array[0]++;assert(array[0] ==*ptr);",
    "answer": false
  },
  {
    "text": "The  definition  above  declaresresolveas  a  pointer  to  a  function  that  takes  twoarguments of typevoid*and returns a void pointer as result.",
    "code": "typedef void (*resolve)(void*old, void*new);",
    "answer": false
  },
  {
    "text": "Memory allocated by themalloc()function is located on the call stack at the high endof the address space.",
    "code": null,
    "answer": false
  },
  {
    "text": "Finite State Machines can be coded in a number of ways in C.- In the function-based solution, every state is encoded as a separate function.",
    "code": null,
    "answer": true
  },
  {
    "text": "GDB is programming tool that provides controlled execution of an executable.- it also provides post mortem inspection when a core file is generated.",
    "code": null,
    "answer": true
  },
  {
    "text": "An interrupt service routine should restore the context upon entrance.",
    "code": null,
    "answer": false
  },
  {
    "text": "Using interrupts avoid wasting time in polling loops for external events",
    "code": null,
    "answer": true
  },
  {
    "text": "To guarantee atomicity critical sections must be disabled.",
    "code": null,
    "answer": false
  },
  {
    "text": "An interrupt vector points to a table with interrupt routines.",
    "code": null,
    "answer": false
  },
  {
    "text": "When a processor is powered up, the state of the interrupt controller needs to be initializedbefore the RTOS can be invoked.",
    "code": null,
    "answer": false
  },
  {
    "text": "The  above  pseudo  code  correctly  dis-/enables  the  interrupts  to  solve  the  shared-dataproblem.\\",
    "code": "static int iSeconds, iMinutes;void interrupt vUpdateTime(void){++iSeconds;if (iSeconds>=60){iSeconds=0;++iMinutes;}}long lSeconds(void){disable();int now = iMinutes*60+iSeconds;enable();return(now);}",
    "answer": true
  },
  {
    "text": "Given the following pseudo code, which reads the current values of 3 different buttonsand acts accordingly. The 3 buttons are all mapped to bits 0..2 of the button register. Thebuttons are already debounced.This code is an example of an RR architecture.",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void main (void){while (1){if (buttons & 0x01) f1();delay(1000);if (buttons & 0x02 ) f2();delay(1000);if (buttons & 0x04 ) f3();}}",
    "answer": true
  },
  {
    "text": "When none of the buttons have been pressed,  the longest time that button #2 must bepressed to activate f2() once is 2 seconds.",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void main (void){while (1){if (buttons & 0x01) f1();delay(1000);if (buttons & 0x02 ) f2();delay(1000);if (buttons & 0x04 ) f3();}}",
    "answer": true
  },
  {
    "text": "When the system is in an arbitrary state, button #1 must be pressed at most 8 seconds toactivate f1().",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void main (void){while (1){if (buttons & 0x01) f1();delay(1000);if (buttons & 0x02 ) f2();delay(1000);if (buttons & 0x04 ) f3();}}",
    "answer": false
  },
  {
    "text": "Since  disabling  interrupts  increases  interrupt  latency,  several  alternative  methods  havebeen developed for dealing with shared data.- The Alternating Buffers technique can be used between two “communicating” tasks ofequal priority.",
    "code": null,
    "answer": false
  },
  {
    "text": "Priority inversionrequires a minimum of 3 tasks of different priority and 1 semaphoreto occur.",
    "code": null,
    "answer": true
  },
  {
    "text": "On 8-bit processors the number of interrupt priorities is limited to 256 (28).",
    "code": null,
    "answer": false
  },
  {
    "text": "Given is the following RTOS (pseudo) code with priority T1>T2. This code suffers from a data sharing problem.",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timeOSPend(mutex);f(1);OSPost(mutex);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timeOSPend(mutex);f(-1);OSPost(mutex);}}void f(int i){counter = counter + i ; // modify some global counter}",
    "answer": false
  },
  {
    "text": "The functionf()is reentrant",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timeOSPend(mutex);f(1);OSPost(mutex);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timeOSPend(mutex);f(-1);OSPost(mutex);}}void f(int i){counter = counter + i ; // modify some global counter}",
    "answer": false
  },
  {
    "text": "With an RR architecture, the handling of I/O devices occurs in a fixed order.",
    "code": null,
    "answer": true
  },
  {
    "text": "An FQS architecture supports priority-based task scheduling.",
    "code": null,
    "answer": true
  },
  {
    "text": "With an RTOS every task needs its own stack.",
    "code": null,
    "answer": true
  },
  {
    "text": "An RR architecture is most robust to code changes.",
    "code": null,
    "answer": false
  },
  {
    "text": "Theprimaryshortcoming of an RRI architecture is that all tasks have the same priority.",
    "code": null,
    "answer": true
  },
  {
    "text": "When detecting a car crash an airbag should not be inflated instantly.- An RR architecture provides functionality to support such delayed actions.",
    "code": null,
    "answer": false
  },
  {
    "text": "An ISR can signal a task by operating a semaphore.",
    "code": null,
    "answer": true
  },
  {
    "text": "A function can be made reentrant by means of a critical section, but then it may no longerbe called by an ISR.",
    "code": null,
    "answer": true
  },
  {
    "text": "In an RTOS, tasks can be in state BLOCKED, READY or RUNNING.- A task can transition directly from READY to BLOCKED.",
    "code": null,
    "answer": false
  },
  {
    "text": "A reentrant function may only be used by one task at a time",
    "code": null,
    "answer": false
  },
  {
    "text": "A program running on an RTOS may create tasks dynamically at runtime.- the program ends oncemain()and all spawned tasks have finished.",
    "code": null,
    "answer": true
  },
  {
    "text": "The  ’alternating  buffers’  technique  addresses  the  shared-data  problem  by  having  theRTOS control when to switch between buffers.",
    "code": null,
    "answer": false
  },
  {
    "text": "In the implementation of theOSPend()primitive, the RTOS first switches the state ofthe current task to BLOCKED, and then looks for a task in the READY queue.- if the READY queue is empty the processor may be put into sleep mode to save energywhen idling.",
    "code": null,
    "answer": true
  },
  {
    "text": "A semaphore used for condition synchronization must be initialized to 1.",
    "code": null,
    "answer": false
  },
  {
    "text": "Functionf()disables/enables interrupts to address the shared-data problem.- However, whenf()calls itself recursively, it is no longer reentrant.",
    "code": "int f (int x){disableint();!!  read some global variables!!  do some processing, call some functions!!  write some global variablesenableint();}",
    "answer": true
  },
  {
    "text": "Tasks may call theOSpend()routine, but not theOSpost()routine .",
    "code": null,
    "answer": false
  },
  {
    "text": "The accuracy of aOSTimeDly()depends on the frequency of the periodic timer usedby the OS.- the higher the frequency, the lower the accuracy.",
    "code": null,
    "answer": false
  },
  {
    "text": "Theheartbeat timeris a single hardware timer an RTOS is using to verify that the systemis still progressing (i.e. not deadlocked).",
    "code": null,
    "answer": false
  },
  {
    "text": "To address the shared-data problem, many RTOSs provide communication primitives likequeues, mailboxes, and pipes.- the basic read/write operations on these primitives are atomic.",
    "code": null,
    "answer": true
  },
  {
    "text": "The advantage of pipes over queues is that messages/items can be of variable length.",
    "code": null,
    "answer": true
  },
  {
    "text": "As  the  RTOSs  is  aware  of  which  task  is  using  which  semaphore,  deadlock  can  beprevented by delaying theOSPendoperation of the last runnable task.",
    "code": null,
    "answer": false
  },
  {
    "text": "With the X32 RTOS creating a task amounts to initializing a stack and invoking a contextswitch to the task’s main function.- This approach provides the possibility to use one stack for multiple (concurrent) tasksand reduce the memory footprint.",
    "code": null,
    "answer": false
  },
  {
    "text": "An advantage of using tasks is that it allows for better data encapsulation.",
    "code": null,
    "answer": true
  },
  {
    "text": "A key principle of RTOS-based design is that short interrupt routines are needed for aresponsive system",
    "code": null,
    "answer": true
  },
  {
    "text": "Printing from an ISR is to be avoided except when the RTOS provides a reentrant primitiveto do so.",
    "code": null,
    "answer": true
  },
  {
    "text": "Time-slicing should be avoided in an RTOS because it introduces the shared-data problem.",
    "code": null,
    "answer": false
  },
  {
    "text": "A semaphore S used by task A must be initialized before A is created.",
    "code": null,
    "answer": false
  },
  {
    "text": "Tasks should have different priorities to prevent the RTOS selecting the wrong task.",
    "code": null,
    "answer": false
  },
  {
    "text": "When developing code for an embedded system, the software can de structured into HW-dependent and HW-independent code.- Doing so makes debugging HW-independent code feasible on the host platform",
    "code": "When developing code for an embedded system, the software can de structured into HW-dependent and HW-independent code.- Doing so makes debugging HW-independent code feasible on the host platform",
    "answer": true
  },
  {
    "text": "Debugging  through  scripting  test  scenarios  is  difficult  when  the  target  platform  isunavailable.",
    "code": null,
    "answer": false
  },
  {
    "text": "Although the assert macro is a useful debugging aid, it can only be used on embeddeddevices with a display.",
    "code": null,
    "answer": false
  },
  {
    "text": "A large study of outdoor sensor-network deployments [Beutel:2009] has shown that themost underestimated problem has been securing the power supply of the sensor nodes.",
    "code": null,
    "answer": false
  },
  {
    "text": "When debugging code for a distributed sensor network, collecting the (debug) output ofthe nodes can be arranged in different ways.-offlinesniffing requires logging facilities on the sniffer nodes.",
    "code": null,
    "answer": true
  },
  {
    "text": "Embedded programming is more difficult than “classical” programming because of thethread-based programming model.",
    "code": null,
    "answer": false
  },
  {
    "text": "A defining characteristic of embedded systems is the usage of a rich user interface.",
    "code": null,
    "answer": false
  },
  {
    "text": "TheEmbedded software crisisrefers to  the decrease in the  number of manufacturedembedded systems.",
    "code": null,
    "answer": false
  },
  {
    "text": "Several models of computation for embedded systems are described in [Lee:2002].- Process Networks are primarily used to describe concurrency at the hardware level.",
    "code": null,
    "answer": false
  },
  {
    "text": "An embedded program can be coded as a finite state machine where interrupts triggerstate transitions.",
    "code": null,
    "answer": true
  },
  {
    "text": "An interrupt is an asynchronous signal from hardware to indicate the need for processorattention.",
    "code": null,
    "answer": true
  },
  {
    "text": "Finite State Machines can be coded in VHDL.- An advantage of doing so is that it results in lower interrupt latency as less context (e.g.,registers) need to be saved and restored.",
    "code": null,
    "answer": false
  },
  {
    "text": "The C language does not contain a built-in type to represent booleans.- True and False are handled as numeric values 1 and 0, respectively.",
    "code": null,
    "answer": false
  },
  {
    "text": "Memory allocated by themalloc()function is located on the data heap above the code.",
    "code": null,
    "answer": true
  },
  {
    "text": "The  definition  above  declaresresolveas  a  pointer  to  a  function  that  takes  twoarguments of typevoid*and returns a void as result.",
    "code": null,
    "answer": false
  },
  {
    "text": "GDB is programming tool that aids memory debugging by executing a program in a safeenvironment.",
    "code": null,
    "answer": false
  },
  {
    "text": "The above driver loop for a FSM follows a round-robin architecture.",
    "code": "int main(void){int c;statefp state = before;while((c = getchar()) != EOF){state = (statefp) (*state)(c);}return 0;}",
    "answer": false
  },
  {
    "text": "Specifying the type ofstatefpis difficult in C because it is recursive and types cannotbe referenced before being fully defined.- This explains the need for an explicit type cast in the body of the while loop.",
    "code": "int main(void){int c;statefp state = before;while((c = getchar()) != EOF){state = (statefp) (*state)(c);}return 0;}",
    "answer": true
  },
  {
    "text": "Using interrupts improves task response time.",
    "code": null,
    "answer": false
  },
  {
    "text": "Disabling interrupts guarantees atomicity of the code until they are enabled again.",
    "code": null,
    "answer": true
  },
  {
    "text": "An interrupt service routine should save the context upon entrance.",
    "code": null,
    "answer": true
  },
  {
    "text": "A low-priority ISR can be interrupted by a high-priority ISR.",
    "code": null,
    "answer": true
  },
  {
    "text": "The above pseudo code suffers from the shared-data problem.",
    "code": "int temp1, temp2;void isrbuttons(void) // arrive here if a button is pressed{temp1 = X32PERIPHERALS[PERIPHERALTEMP1];temp2 = X32PERIPHERALS[PERIPHERALTEMP2];...}main(){...while (!programdone){X32display = ((temp1 & 0xff) << 8) | (temp2 & 0xff);if (temp1 != temp2){// shutdown plant}}}",
    "answer": true
  },
  {
    "text": "The shared-data problem can be solved by storing data in non-volatile memory.",
    "code": null,
    "answer": false
  },
  {
    "text": "Critical sections can be guarded by disabling and enabling interrupts.- interrupts arriving during such a critical section are buffered and handled upon exit.",
    "code": null,
    "answer": true
  },
  {
    "text": "When a processor is powered up, the state of the interrupt controller needs to be initializedbefore the RTOS can be invoked.",
    "code": null,
    "answer": false
  },
  {
    "text": "Priority inversionoccurs when thevolatileandstatickeywords are wrongly usedinside a task or interrupt.",
    "code": null,
    "answer": false
  },
  {
    "text": "Writing to the global variablecountis atomic.",
    "code": "static volatile int count;main (){...count = 666;...}",
    "answer": false
  },
  {
    "text": "The worst-case latency for servicing an interrupt is a combination of factors, includingthe longest period of time in which interrupts are disabled.",
    "code": null,
    "answer": true
  },
  {
    "text": "The number of interrupts is limited by the number of GPIO pins on the processor.",
    "code": null,
    "answer": false
  },
  {
    "text": "An interrupt vector table contains the code of the interrupt service routines.",
    "code": null,
    "answer": false
  },
  {
    "text": "Since  disabling  interrupts  increases  interrupt  latency,  several  alternative  methods  havebeen developed for dealing with shared data. The Alternating Buffers method is suited forhanding data from an ISR to a task. The code for toggling theuseBflag should be in the main task (not the ISR) as shownabove.",
    "code": "static int tempA[2], tempB[2];static bool useB = FALSE;void interrupt readTemp(){if (useB){tempA[0]= ...;tempA[1]= ...;}else{tempB[0]= ...;tempB[1]= ...;}}void main(void){while (TRUE){if (useB)if (tempB[0]!=tempB[1]) ...  ;elseif (tempA[0]!=tempA[1]) ...  ;useB = !useB;}}",
    "answer": true
  },
  {
    "text": "An RR architecture supports priority-based task scheduling.",
    "code": null,
    "answer": false
  },
  {
    "text": "With an RRI architecture, the execution of a task associated with a high-priority interruptmay be delayed by other tasks in the system.",
    "code": null,
    "answer": true
  },
  {
    "text": "An FQS architecture has a smaller memory footprint than an RTOS as it needs only onestack.",
    "code": null,
    "answer": true
  },
  {
    "text": "Consider an alarm system that constantly monitors the digital output of several motiondetector sensors in a house.  If a breach is detected then an intermittent alarm sound istriggered.- That alarm system can be implemented with an RR architecture.",
    "code": null,
    "answer": true
  },
  {
    "text": "The response time to an external event in an FQS architecture is deterministic and dependssolely on the length of the ISR.",
    "code": null,
    "answer": false
  },
  {
    "text": "When detecting a car crash an airbag should not be inflated instantly.- An RTOS provides functionality to support such delayed actions.",
    "code": null,
    "answer": true
  },
  {
    "text": "When upgrading to an RTOS, signaling between ISRs and tasks may still be done throughflags residing in global memory.",
    "code": null,
    "answer": false
  },
  {
    "text": "In an RTOS, tasks can be in state BLOCKED, READY or RUNNING.- A task can transition directly from BLOCKED to RUNNING.",
    "code": null,
    "answer": false
  },
  {
    "text": "An ISR mustnotinvoke an RTOS function that may block.",
    "code": null,
    "answer": true
  },
  {
    "text": "A reentrant function may only be used by one task at a time",
    "code": null,
    "answer": false
  },
  {
    "text": "Semaphores can be used for signaling between tasks.",
    "code": null,
    "answer": true
  },
  {
    "text": "Tasks may call theOSpend()routine, but not theOSpost()routine .",
    "code": null,
    "answer": false
  },
  {
    "text": "A program running on an RTOS may create tasks dynamically at runtime.- the program ends oncemain()and all spawned tasks have finished.",
    "code": null,
    "answer": true
  },
  {
    "text": "In the implementation of theOSPend()primitive, the RTOS first switches the state ofthe current task to BLOCKED, and then looks for a task in the READY queue.- if the READY queue is empty the RTOS starts a watchdog timer to guard for a potentialdeadlock.",
    "code": null,
    "answer": false
  },
  {
    "text": "Given is the following RTOS (pseudo) code with priority T1>T2. The functionf()is reentrant.",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);}}void f(int i){delay(10); // do some computationcounter = counter + i ; // modify some global counterprintf(\"%d\\n\", counter) ; // print result}",
    "answer": false
  },
  {
    "text": "Ifcounteris set to 15 when event 2 occurs, and event 1 follows 13 ms later, then thefirst value printed is 15.",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);}}void f(int i){delay(10); // do some computationcounter = counter + i ; // modify some global counterprintf(\"%d\\n\", counter) ; // print result}",
    "answer": false
  },
  {
    "text": "If the call todelayis replaced withOSTimeDlythe output will be different.",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);}}void f(int i){delay(10); // do some computationcounter = counter + i ; // modify some global counterprintf(\"%d\\n\", counter) ; // print result}",
    "answer": false
  },
  {
    "text": "An RTOS usually provides two types of delay functions: polling-based and timer-based.- polling-based delays are the most accurate.",
    "code": null,
    "answer": true
  },
  {
    "text": "Assume that one system clock tick = 10 ms.- Calling the functionOSTimeDly(5)causes a delay between 40 and 50 ms.",
    "code": null,
    "answer": true
  },
  {
    "text": "To address the shared-data problem, many RTOSs provide communication primitives likequeues, mailboxes, and pipes.- a common advantage is that they allow pointers to be passed from one task to another.",
    "code": null,
    "answer": false
  },
  {
    "text": "The advantage of queues over pipes is that messages/items can be of variable length.",
    "code": null,
    "answer": false
  },
  {
    "text": "Even when an RTOS is aware of which task is using which semaphore, it cannot preventdeadlock.",
    "code": null,
    "answer": true
  },
  {
    "text": "Tasks  in  an  RTOS  are  often  structured  as  state  machines  with  states  stored  in  privatevariables and messages in their queues acting as events.",
    "code": null,
    "answer": true
  },
  {
    "text": "The memory footprint of a program grows linearly with the number of tasks.",
    "code": null,
    "answer": true
  },
  {
    "text": "Printing from an ISR is considered a good practice as no other debugging techniques areavailable.",
    "code": null,
    "answer": false
  },
  {
    "text": "Time  slicing  between  tasks  of  equal  priority  is  to  be  avoided  as  the  response  time  ofindividual tasks is comprised.",
    "code": null,
    "answer": true
  },
  {
    "text": "A semaphore S used by task A must be initialized by A.",
    "code": null,
    "answer": false
  },
  {
    "text": "Aborting tasks is nontrivial because a task may hold resources (e.g., a semaphore) whenbeing destroyed.",
    "code": null,
    "answer": true
  },
  {
    "text": "A logic analyzer is preferred to an in-circuit emulator because it can monitor the internalmemory bus of (most) modern micro controllers.",
    "code": null,
    "answer": false
  },
  {
    "text": "Code coverage tools help in thorough testing.- a 100% coverage implies a bug-free program.",
    "code": null,
    "answer": false
  },
  {
    "text": "Even on embedded deviceswithouta display, the assert macro is a useful debugging aid.",
    "code": null,
    "answer": true
  },
  {
    "text": "A large study of outdoor sensor-network deployments [Beutel:2009] has shown that thewater-proof packaging of the base station is key to establishing a reliable connection tothe back bone.",
    "code": null,
    "answer": false
  },
  {
    "text": "When debugging code for a distributed sensor network, collecting the (debug) output ofthe nodes can be arranged in different ways.- Awirelesstestbed requires physical instrumentation (i.e. wiring) of the sensor node.",
    "code": null,
    "answer": true
  },
  {
    "text": "Embedded programming is more difficult than “classical” programming because of thelack of support for recursion.",
    "code": null,
    "answer": false
  },
  {
    "text": "A defining characteristic of embedded systems is the restricted, or complete lack, of a userinterface.",
    "code": null,
    "answer": true
  },
  {
    "text": "Several models of computation for embedded systems are described in [Lee:2002].-  The  ROS  software  (used  in  the  practicals)  is  a  prime  example  of  the  publish-and-subscribe model.",
    "code": null,
    "answer": true
  },
  {
    "text": "The  Underground  Tank  Monitoring  System  is  a  somewhat  contrived  example  of  anembedded system as it involves input (sensors/buttons) and output (display/printer), butlacks real-time constraints and resource limitations.",
    "code": null,
    "answer": false
  },
  {
    "text": "Despite  advances  in  software  engineering  practices,  as  a  rule  of  thumb,  embeddedsoftware contains 1-10 bugs per thousand lines of code.",
    "code": null,
    "answer": true
  },
  {
    "text": "Hardware interrupts can be disabled; software interrupts cannot.",
    "code": null,
    "answer": false
  },
  {
    "text": "An embedded program can be coded as a finite state machine; the number of incomingtransitions (arcs) into a state S must equal the number of outgoing transitions (arcs).",
    "code": null,
    "answer": false
  },
  {
    "text": "Finite State Machines can be coded in a number of ways in C.- In the table-based solution, every transition (arc) is encoded as a separate function.",
    "code": null,
    "answer": true
  },
  {
    "text": "The above loop drives the FSM until the end state is reached.",
    "code": "int main(void){int c;statefp state = start;while((c = getchar()) != EOF){state = (statefp) (*state)(c);}return 0;}",
    "answer": false
  },
  {
    "text": "Unlike recursive data structures, recursive function types cannot be properly defined in Cand require kludges likevoidpointers and type casts.",
    "code": "int main(void){int c;statefp state = start;while((c = getchar()) != EOF){state = (statefp) (*state)(c);}return 0;}",
    "answer": true
  },
  {
    "text": "The C language does not contain a built-in type to represent booleans.- in control flow statements, expressions evaluating to 0 are regarded as logically False.",
    "code": null,
    "answer": true
  },
  {
    "text": "The  first  pair  of  parenthesis  in  the  definition  above  is  for  clarity  (stressing  a  functionpointer is involved) and can be left out without changing the meaning.",
    "code": "typedef void (*resolve)(void*old, void*new);",
    "answer": false
  },
  {
    "text": "Valgrind is programming tool that provides controlled execution, as well as post morteminspection of an executable.",
    "code": null,
    "answer": false
  },
  {
    "text": "The worst-case latency for servicing an interrupt is a combination of factors, includingthe time taken for higher priority interrupts.",
    "code": null,
    "answer": true
  },
  {
    "text": "Despite disabling interrupts the above pseudo code fails to solve the shared-data problem.",
    "code": "static int iSeconds, iMinutes;void interrupt vUpdateTime(void){++iSeconds;if (iSeconds>=60){iSeconds=0;++iMinutes;}}long lSeconds(void){disable();return (iMinutes*60+iSeconds);enable();}",
    "answer": true
  },
  {
    "text": "An interrupt vector table contains the addresses of the interrupt service routines.",
    "code": null,
    "answer": true
  },
  {
    "text": "An interrupt cannotbe serviced faster than the time needed to save the context of coderunning on the processor.",
    "code": null,
    "answer": true
  },
  {
    "text": "Critical sections can be guarded by disabling and enabling interrupts.- interrupts arriving during such a critical section are buffered and handled upon exit.",
    "code": null,
    "answer": true
  },
  {
    "text": "Given is the following RTOS (pseudo) code with priority T1>T2. This code suffers from a data sharing problem.",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);OSTimeDly(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);OSTimeDly(3);}}void f(int i){OSPend(mutex);counter = counter + i ; // modify some global counterOSPost(mutex);}",
    "answer": false
  },
  {
    "text": "If the order of events is  1,  2,  1,  2,  1 and they occur within 10  ms from each other, thenthe final value of the counter will be increased by 1.",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);OSTimeDly(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);OSTimeDly(3);}}void f(int i){OSPend(mutex);counter = counter + i ; // modify some global counterOSPost(mutex);}",
    "answer": true
  },
  {
    "text": "The functionf()is reentrant",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);OSTimeDly(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);OSTimeDly(3);}}void f(int i){OSPend(mutex);counter = counter + i ; // modify some global counterOSPost(mutex);}",
    "answer": true
  },
  {
    "text": "The shared-data problem can be solved through enabling interrupts.",
    "code": null,
    "answer": false
  },
  {
    "text": "Adeadly embracerequires a minimum of 3 tasks of different priority and 1 semaphoreto occur.",
    "code": null,
    "answer": false
  },
  {
    "text": "When a processor is powered up, interrupts are disabled until further notice.",
    "code": null,
    "answer": true
  },
  {
    "text": "While interrupts are disabled atomicity is guaranteed even when calling a non-reentrantfuncion.",
    "code": null,
    "answer": true
  },
  {
    "text": "Shared variables markedvolatileguarantee atomic access.",
    "code": null,
    "answer": false
  },
  {
    "text": "Using interrupts improves system response time.",
    "code": null,
    "answer": true
  },
  {
    "text": "Theprimaryshortcoming of an RRI architecture is that it is more complex than RR.",
    "code": null,
    "answer": false
  },
  {
    "text": "An RTOS architecture supports priority-based ISRs.",
    "code": null,
    "answer": true
  },
  {
    "text": "With an FQS architecture, the worst response time of a task includes the time taken by thelongest task in the system.",
    "code": null,
    "answer": true
  },
  {
    "text": "With an RTOS every task needs its own stack.",
    "code": null,
    "answer": true
  },
  {
    "text": "An RR architecture is most robust to code changes.",
    "code": null,
    "answer": false
  },
  {
    "text": "With an RTOS it is impossible to make direct use of harware timers.",
    "code": null,
    "answer": false
  },
  {
    "text": "In an RTOS, tasks can be in state BLOCKED, READY or RUNNING.- a task starts in the state RUNNING.",
    "code": null,
    "answer": false
  },
  {
    "text": "An ISR may change a task’s status from BLOCKED to READY.",
    "code": null,
    "answer": true
  },
  {
    "text": "A high-priority task mustnotinvoke an RTOS function that may block.",
    "code": null,
    "answer": false
  },
  {
    "text": "When  using  an  RTOS  signaling  between  ISRs  and  tasks  must  be  done  by  callingappropriate RTOS primitives.",
    "code": null,
    "answer": true
  },
  {
    "text": "A program running on an RTOS may create tasks dynamically at runtime.- the number of tasks is limited by the number of priority levels supported.",
    "code": null,
    "answer": false
  },
  {
    "text": "An RTOS usually provides two types of delay functions: polling-based and timer-based.- timer-based delays are more efficient as other tasks can run while the caller is waitingfor the specified time to pass.",
    "code": null,
    "answer": true
  },
  {
    "text": "Assume that one system clock tick = 10 ms.- Calling the functionOSTimeDly(6)causes a delay between 50 and 70 ms.",
    "code": null,
    "answer": false
  },
  {
    "text": "To address the shared-data problem, many RTOSs provide communication primitives likequeues, mailboxes, and pipes.- a common advantage is that they allow pointers to be passed from one task to another.",
    "code": null,
    "answer": false
  },
  {
    "text": "A disadvantage of queues over pipes is that messages/items are handled strictly in FIFOorder.",
    "code": null,
    "answer": false
  },
  {
    "text": "With the X32 RTOS creating a task amounts to initializing a stack and invoking a contextswitch to the task’s main function.- This approach provides the possibility to use one stack for multiple (concurrent) tasksand reduce the memory footprint.",
    "code": null,
    "answer": false
  },
  {
    "text": "Theheartbeat timeris a single hardware timer an RTOS is using to monitor the livenessof the task set involved.",
    "code": null,
    "answer": false
  },
  {
    "text": "This code is an example of an RRI architecture.",
    "code": "1#include<stdio.h>2#include<string.h>3#include<stdlib.h>45extern char*UART_rx_buf;// copied from <uart.h> for reference6extern char*UART_tx_buf;7extern char*UART_ier;89#defineLEN 8010static char*next_command = NULL;1112voidrx_ready() {13static charbuffer[2][LEN];14static inttoggle = 0;15static char*command = buffer[0];16static intcnt = 0;1718charc =*UART_rx_buf;19if(c == ’\\n’) {20command[cnt] = ’\\0’;21next_command = command;22toggle = 1 - toggle;23command = buffer[toggle];24cnt = 0;25}else{26command[cnt++] = c;27}28}2930intmain() {31*UART_ier |= 0x3;// start RX and TX please32while(1) {33if(next_command != NULL) {34if(strcmp(next_command, \"exit\") == 0) {35exit(0);36}else if(strcmp(next_command, \"hello\") == 0) {37printf(\"world\\n\");38}39next_command = NULL;40}41...42}43}",
    "answer": true
  },
  {
    "text": "Consider  lines  5-7  in  which  some  of  a  UART’s  registers  are  declared.    This  way  aUART, or any other peripheral for that matter, can be accessed with normal read/writeinstructions.- this mode of operation is called ’memory-mapped I/O’.",
    "code": "1#include<stdio.h>2#include<string.h>3#include<stdlib.h>45extern char*UART_rx_buf;// copied from <uart.h> for reference6extern char*UART_tx_buf;7extern char*UART_ier;89#defineLEN 8010static char*next_command = NULL;1112voidrx_ready() {13static charbuffer[2][LEN];14static inttoggle = 0;15static char*command = buffer[0];16static intcnt = 0;1718charc =*UART_rx_buf;19if(c == ’\\n’) {20command[cnt] = ’\\0’;21next_command = command;22toggle = 1 - toggle;23command = buffer[toggle];24cnt = 0;25}else{26command[cnt++] = c;27}28}2930intmain() {31*UART_ier |= 0x3;// start RX and TX please32while(1) {33if(next_command != NULL) {34if(strcmp(next_command, \"exit\") == 0) {35exit(0);36}else if(strcmp(next_command, \"hello\") == 0) {37printf(\"world\\n\");38}39next_command = NULL;40}41...42}43}",
    "answer": true
  },
  {
    "text": "The functionrxready()uses a technique called ’alternating buffers’.- From line 13 we can infer that the buffers are allocated on the call stack.",
    "code": "1#include<stdio.h>2#include<string.h>3#include<stdlib.h>45extern char*UART_rx_buf;// copied from <uart.h> for reference6extern char*UART_tx_buf;7extern char*UART_ier;89#defineLEN 8010static char*next_command = NULL;1112voidrx_ready() {13static charbuffer[2][LEN];14static inttoggle = 0;15static char*command = buffer[0];16static intcnt = 0;1718charc =*UART_rx_buf;19if(c == ’\\n’) {20command[cnt] = ’\\0’;21next_command = command;22toggle = 1 - toggle;23command = buffer[toggle];24cnt = 0;25}else{26command[cnt++] = c;27}28}2930intmain() {31*UART_ier |= 0x3;// start RX and TX please32while(1) {33if(next_command != NULL) {34if(strcmp(next_command, \"exit\") == 0) {35exit(0);36}else if(strcmp(next_command, \"hello\") == 0) {37printf(\"world\\n\");38}39next_command = NULL;40}41...42}43}",
    "answer": false
  },
  {
    "text": "The code suffers from a (subtle) data sharing bug as bothrxready()andmain()write to the same global variablenextcommand.- in certain casesrxready()will overwrite buffered data still to be read bymain().",
    "code": "1#include<stdio.h>2#include<string.h>3#include<stdlib.h>45extern char*UART_rx_buf;// copied from <uart.h> for reference6extern char*UART_tx_buf;7extern char*UART_ier;89#defineLEN 8010static char*next_command = NULL;1112voidrx_ready() {13static charbuffer[2][LEN];14static inttoggle = 0;15static char*command = buffer[0];16static intcnt = 0;1718charc =*UART_rx_buf;19if(c == ’\\n’) {20command[cnt] = ’\\0’;21next_command = command;22toggle = 1 - toggle;23command = buffer[toggle];24cnt = 0;25}else{26command[cnt++] = c;27}28}2930intmain() {31*UART_ier |= 0x3;// start RX and TX please32while(1) {33if(next_command != NULL) {34if(strcmp(next_command, \"exit\") == 0) {35exit(0);36}else if(strcmp(next_command, \"hello\") == 0) {37printf(\"world\\n\");38}39next_command = NULL;40}41...42}43}",
    "answer": true
  },
  {
    "text": "Removing the write statement on line 39 will not resolve the shared data bug.- it will causemain()to repeat the same command untilrxready()is invoked again.",
    "code": "1#include<stdio.h>2#include<string.h>3#include<stdlib.h>45extern char*UART_rx_buf;// copied from <uart.h> for reference6extern char*UART_tx_buf;7extern char*UART_ier;89#defineLEN 8010static char*next_command = NULL;1112voidrx_ready() {13static charbuffer[2][LEN];14static inttoggle = 0;15static char*command = buffer[0];16static intcnt = 0;1718charc =*UART_rx_buf;19if(c == ’\\n’) {20command[cnt] = ’\\0’;21next_command = command;22toggle = 1 - toggle;23command = buffer[toggle];24cnt = 0;25}else{26command[cnt++] = c;27}28}2930intmain() {31*UART_ier |= 0x3;// start RX and TX please32while(1) {33if(next_command != NULL) {34if(strcmp(next_command, \"exit\") == 0) {35exit(0);36}else if(strcmp(next_command, \"hello\") == 0) {37printf(\"world\\n\");38}39next_command = NULL;40}41...42}43}",
    "answer": true
  },
  {
    "text": "An alternative approach would be to make use of semaphores to supportrxready()passing the next command tomain().- only a single semaphore initialized to 0 is needed.",
    "code": "1#include<stdio.h>2#include<string.h>3#include<stdlib.h>45extern char*UART_rx_buf;// copied from <uart.h> for reference6extern char*UART_tx_buf;7extern char*UART_ier;89#defineLEN 8010static char*next_command = NULL;1112voidrx_ready() {13static charbuffer[2][LEN];14static inttoggle = 0;15static char*command = buffer[0];16static intcnt = 0;1718charc =*UART_rx_buf;19if(c == ’\\n’) {20command[cnt] = ’\\0’;21next_command = command;22toggle = 1 - toggle;23command = buffer[toggle];24cnt = 0;25}else{26command[cnt++] = c;27}28}2930intmain() {31*UART_ier |= 0x3;// start RX and TX please32while(1) {33if(next_command != NULL) {34if(strcmp(next_command, \"exit\") == 0) {35exit(0);36}else if(strcmp(next_command, \"hello\") == 0) {37printf(\"world\\n\");38}39next_command = NULL;40}41...42}43}",
    "answer": true
  },
  {
    "text": "Time  slicing  between  tasks  of  equal  priority  is  to  be  avoided  as  it  compromises  thepredictability of their response times.",
    "code": null,
    "answer": true
  },
  {
    "text": "The minimal memory footprint of a program grows linearly with the number of tasks.",
    "code": null,
    "answer": true
  },
  {
    "text": "A semaphore S used by tasks A and B must be initialized by either A or B.",
    "code": null,
    "answer": false
  },
  {
    "text": "An advantage of using tasks is that it allows for better data encapsulation.",
    "code": null,
    "answer": true
  },
  {
    "text": "Tasks should have different priorities to avoid fairness issues imposed by the RTOS.",
    "code": null,
    "answer": false
  },
  {
    "text": "When developing code for an embedded system, the software can de structured into HW-dependent and HW-independent code.- Doing so makes debugging HW-independent code feasible on the target platform",
    "code": null,
    "answer": false
  },
  {
    "text": "A logic analyzer is preferred to an in-circuit emulator because it can be used with any typeof processor.",
    "code": null,
    "answer": true
  },
  {
    "text": "Although the assert macro is a useful debugging aid during program development, it canonly be used on the host.",
    "code": null,
    "answer": false
  },
  {
    "text": "A large study of outdoor sensor-network deployments [Beutel:2009] has shown that thewater-proof packaging of the base station is key to establishing a reliable connection tothe back bone.",
    "code": null,
    "answer": false
  },
  {
    "text": "When debugging code for a distributed sensor network, collecting the (debug) output ofthe nodes can be arranged in different ways.- Awirelesstestbed requiresnophysical instrumentation (i.e. wiring) of the sensor nodes.",
    "code": null,
    "answer": false
  },
  {
    "text": "Embedded programming is more difficult than “classical” programming because of thelack of support for recursion.",
    "code": null,
    "answer": false
  },
  {
    "text": "A defining characteristic of embedded systems is the usage of a rich user interface.",
    "code": null,
    "answer": false
  },
  {
    "text": "Because embedded software engages the physical world, it has to embrace time and othernon-functional properties, which requires a view that is significantly different from theprevailing abstractions in computation.",
    "code": null,
    "answer": true
  },
  {
    "text": "Finite State Machines can be coded in VHDL.- An advantage of doing so is that it results in a fast and predictable process executing ondedicated hardware.",
    "code": null,
    "answer": true
  },
  {
    "text": "Interrupts cannot only be generated by hardware, but also by software.- A software interrupt is a synchronous signal to indicate the need for a change in theexecution flow.",
    "code": null,
    "answer": true
  },
  {
    "text": "An embedded program can be coded as a finite state machine.- When for every state S the number of incoming transitions (arcs) equals the number ofoutgoing transitions (arcs), the code is free of deadlocks.",
    "code": null,
    "answer": false
  },
  {
    "text": "Besides  Finite  State  Machines  other  models  of  computation  suitable  for  embeddedsystems include Symbolic Execution and Discrete Events.",
    "code": null,
    "answer": false
  },
  {
    "text": "The size of anintis architecture dependent, but defined to be larger than ashort.",
    "code": null,
    "answer": false
  },
  {
    "text": "Memory allocated by themalloc()function is located on the data heap above the code.",
    "code": null,
    "answer": true
  },
  {
    "text": "The  definition  above  declaresresolveas  a  pointer  to  a  function  that  takes  twoarguments of typevoid*and returns a void pointer as result.",
    "code": "typedef void (*resolve)(void*old, void*new);",
    "answer": false
  },
  {
    "text": "The above driver loop for a FSM follows a round-robin architecture.",
    "code": "int main(void){int c;statefp state = before;while((c = getchar()) != EOF){state = (statefp) (*state)(c);}return 0;}",
    "answer": false
  },
  {
    "text": "Specifying the type ofstatefpis difficult in C because it is recursive and types cannotbe referenced before being fully defined.",
    "code": "int main(void){int c;statefp state = before;while((c = getchar()) != EOF){state = (statefp) (*state)(c);}return 0;}",
    "answer": true
  },
  {
    "text": "GDB is programming tool that provides controlled execution of an executable.- it also provides post mortem inspection when a core file is generated.",
    "code": null,
    "answer": true
  },
  {
    "text": "Using interrupts improves system response time.",
    "code": null,
    "answer": true
  },
  {
    "text": "An interrupt service routine should restore the context upon exit.",
    "code": null,
    "answer": true
  },
  {
    "text": "To guarantee atomicity critical sections must be disabled.",
    "code": null,
    "answer": false
  },
  {
    "text": "An ISR cannotbe interrupted by another ISR.",
    "code": null,
    "answer": false
  },
  {
    "text": "When a processor is powered up, the state of the interrupt controller needs to be initializedbefore the RTOS can be invoked.",
    "code": null,
    "answer": false
  },
  {
    "text": "The  above  pseudo  code  correctly  dis-/enables  the  interrupts  to  solve  the  shared-dataproblem.",
    "code": "static int iSeconds, iMinutes;void interrupt vUpdateTime(void){++iSeconds;if (iSeconds>=60){iSeconds=0;++iMinutes;}}long lSeconds(void){disable();int now = iMinutes*60+iSeconds;enable();return(now);}",
    "answer": true
  },
  {
    "text": "An interrupt vector table contains the code of the interrupt service routines.",
    "code": null,
    "answer": false
  },
  {
    "text": "Given the following pseudo code, which reads the current values of 3 different buttonsand acts accordingly. The 3 buttons are all mapped to bits 0..2 of the button register. Thebuttons are already debounced. This code is an example of an RR architecture.",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void main (void){while (1){if (buttons & 0x01) f1();delay(1000);if (buttons & 0x02 ) f2();delay(1000);if (buttons & 0x04 ) f3();}}",
    "answer": true
  },
  {
    "text": "When none of the buttons have been pressed,  the longest time that button #3 must bepressed to activate f3() once is 4 seconds.",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void main (void){while (1){if (buttons & 0x01) f1();delay(1000);if (buttons & 0x02 ) f2();delay(1000);if (buttons & 0x04 ) f3();}}",
    "answer": false
  },
  {
    "text": "When the system is in an arbitrary state, button #1 must be pressed at most 10 seconds toactivate f1().",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void main (void){while (1){if (buttons & 0x01) f1();delay(1000);if (buttons & 0x02 ) f2();delay(1000);if (buttons & 0x04 ) f3();}}",
    "answer": false
  },
  {
    "text": "The worst-case latency for servicing an interrupt is a combination of factors, includingthe time taken for higher priority tasks.",
    "code": null,
    "answer": false
  },
  {
    "text": "The number of interrupts is limited by the number of GPIO pins on the processor.",
    "code": null,
    "answer": false
  },
  {
    "text": "Mutual exclusive access can also be accomplished by disabling interrupts, which has theadvantage of faster context switching compared to using RTOS primitives like semaphoresand mutexes.",
    "code": null,
    "answer": false
  },
  {
    "text": "Priority inversionrequires a minimum of 3 tasks of different priority and 3 semaphoresto occur.",
    "code": null,
    "answer": false
  },
  {
    "text": "Theprimaryshortcoming of an RRI architecture is that all tasks have the same priority.",
    "code": null,
    "answer": true
  },
  {
    "text": "An FQS architecture supports priority-based ISRs.",
    "code": null,
    "answer": true
  },
  {
    "text": "The response time to an external event in an FQS architecture depends on the longest taskin the system.",
    "code": null,
    "answer": true
  },
  {
    "text": "An RR architecture is most robust to code changes.",
    "code": null,
    "answer": false
  },
  {
    "text": "Consider an alarm system that constantly monitors the digital output of several motiondetector sensors in a house.  If a breach is detected then an intermittent alarm sound istriggered.- That alarm system can be implemented with an RR architecture.",
    "code": null,
    "answer": true
  },
  {
    "text": "When detecting a car crash an airbag should not be inflated instantly.- An RTOS provides functionality to support such delayed actions.",
    "code": null,
    "answer": true
  },
  {
    "text": "When upgrading to an RTOS, signaling between ISRs and tasks may still be done throughflags residing in global memory.",
    "code": null,
    "answer": false
  },
  {
    "text": "Semaphores can be used for signaling between ISRs.",
    "code": null,
    "answer": false
  },
  {
    "text": "A reentrant function maynotreference variables labeledextern.",
    "code": null,
    "answer": false
  },
  {
    "text": "A semaphore used for guaranteeing mutual exclusive access to shared resources must beinitialized to 1.",
    "code": null,
    "answer": true
  },
  {
    "text": "A high-priority task mustnotinvoke an RTOS function that may block.",
    "code": null,
    "answer": false
  },
  {
    "text": "The  ’alternating  buffers’  technique  addresses  the  shared-data  problem  by  having  theRTOS control when to switch between buffers.",
    "code": null,
    "answer": false
  },
  {
    "text": "In the implementation of theOSPend()primitive, the RTOS first switches the state ofthe current task to BLOCKED, and then looks for a task in the READY queue.- if the READY queue is empty the processor may be put into sleep mode to save energywhen idling.",
    "code": null,
    "answer": true
  },
  {
    "text": "Functionf()disables/enables interrupts to address the shared-data problem.- However, whenf()calls itself recursively, it is no longer reentrant.",
    "code": null,
    "answer": true
  },
  {
    "text": "Given is the following RTOS (pseudo) code with priority T1>T2. The functionf()is reentrant.",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);}}void f(int i){delay(10); // do some computationcounter = counter + i ; // modify some global counterprintf(\"%d\\n\", counter) ; // print result}",
    "answer": false
  },
  {
    "text": "Ifcounteris set to 15 when event 2 occurs, and event 1 follows 3 ms later, then the firstvalue printed is 16.",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);}}void f(int i){delay(10); // do some computationcounter = counter + i ; // modify some global counterprintf(\"%d\\n\", counter) ; // print result}",
    "answer": true
  },
  {
    "text": "If the call todelayis replaced withOSTimeDlythe output will be different.",
    "code": "void T1(void){while (1){OSPend(sem1); // event #1 may unblock any timef(1);}}void T2(void){while (1){OSPend(sem2); // event #2 may unblock any timef(-1);}}void f(int i){delay(10); // do some computationcounter = counter + i ; // modify some global counterprintf(\"%d\\n\", counter) ; // print result}",
    "answer": false
  },
  {
    "text": "An RTOS usually provides two types of delay functions: polling-based and timer-based.- polling-based delays are more efficient as other tasks can run while the caller is waitingfor the specified time to pass.",
    "code": null,
    "answer": false
  },
  {
    "text": "Assume that one system clock tick = 10 ms.- Calling the functionOSTimeDly(5)causes a delay between 40 and 50 ms.",
    "code": null,
    "answer": true
  },
  {
    "text": "To address the shared-data problem, many RTOSs provide communication primitives likequeues, mailboxes, and pipes.- a common advantage is that they allow pointers to be passed from one task to another.",
    "code": null,
    "answer": false
  },
  {
    "text": "The advantage of queues over pipes is that messages/items can be of variable length.",
    "code": null,
    "answer": false
  },
  {
    "text": "Even when an RTOS is aware of which task is using which semaphore, it cannot preventdeadlock.",
    "code": null,
    "answer": true
  },
  {
    "text": "Tasks  in  an  RTOS  are  often  structured  as  state  machines  with  states  stored  in  privatevariables and messages in their queues acting as events.",
    "code": null,
    "answer": true
  },
  {
    "text": "The memory footprint of a program grows linearly with the number of tasks.",
    "code": null,
    "answer": true
  },
  {
    "text": "Printing from an ISR is to be avoided except when the RTOS provides a reentrant primitiveto do so.",
    "code": null,
    "answer": true
  },
  {
    "text": "Time  slicing  between  tasks  of  equal  priority  is  to  be  avoided  as  it  compromises  thepredictability of their response times.",
    "code": null,
    "answer": true
  },
  {
    "text": "A semaphore S used by task A must be initialized before A is created.",
    "code": null,
    "answer": false
  },
  {
    "text": "It is recommended to use just the minimum necessary functionality from an RTOS.",
    "code": null,
    "answer": true
  },
  {
    "text": "Code coverage tools help in thorough testing.- a 100% coverage implies a bug-free program.",
    "code": null,
    "answer": false
  },
  {
    "text": "A logic analyzer is preferred to an in-circuit emulator because it is easier to install; not allsignals need to be connected.",
    "code": null,
    "answer": true
  },
  {
    "text": "Debugging through scripting test scenarios can only be used to test HW-independent code.",
    "code": null,
    "answer": true
  },
  {
    "text": "A large study of outdoor sensor-network deployments [Beutel:2009] has shown that themost underestimated problem has been securing the power supply of the sensor nodes.",
    "code": null,
    "answer": false
  },
  {
    "text": "When debugging code for a distributed sensor network, collecting the (debug) output ofthe nodes can be arranged in different ways.- Awirelesstestbed requiresnophysical instrumentation (i.e. wiring) of the sensor nodes.",
    "code": null,
    "answer": false
  },
  {
    "text": "A defining characteristic of embedded systems is the need for large volumes of scale.",
    "code": null,
    "answer": false
  },
  {
    "text": "The Underground Tank Monitoring System is a classic example of an embedded system inthat it involves input (sensors/buttons), output (display/printer) and real-time constraints.",
    "code": null,
    "answer": true
  },
  {
    "text": "\tBecause  embedded  software  engages  the  physical  world,  it  has  to  embrace  time  andother non-functional properties, which requires the use of interrupt handlers to guaranteeresponsiveness.",
    "code": null,
    "answer": false
  },
  {
    "text": "An embedded program can be coded as a finite state machine where all state transitionsare triggered by user actions.",
    "code": null,
    "answer": false
  },
  {
    "text": "Several models of computation for embedded systems are described in [Lee:2002].- The ROS software (used in the practicals) is a prime example of the Dataflow model.",
    "code": null,
    "answer": false
  },
  {
    "text": "An interrupt is an asynchronous signal from hardware to indicate the need for processorattention.",
    "code": null,
    "answer": true
  },
  {
    "text": "Finite State Machines can be coded in VHDL.- An advantage of doing so is that it results in lower interrupt latency as less context (e.g.,registers) need to be saved and restored.",
    "code": null,
    "answer": false
  },
  {
    "text": "Finite State Machines can be coded in a number of ways in C.- In the function-based solution, transitions (arcs) are encoded as a function calls.",
    "code": null,
    "answer": false
  },
  {
    "text": "Global variables are located on the data heap by the C runtime support at start of execution.",
    "code": null,
    "answer": false
  },
  {
    "text": "The C language is centered around theintdata type, which is defined to hold integralnumbers of at least 16 bits.",
    "code": null,
    "answer": true
  },
  {
    "text": "GDB is programming tool that aids memory debugging by executing a program in a safeenvironment.",
    "code": null,
    "answer": false
  },
  {
    "text": "The above loop drives the FSM until all characters from the standard input have beenprocessed.",
    "code": "int main(void){int c;statefp state = start;while((c = getchar()) != EOF){state = (statefp) (*state)(c);}return 0;}",
    "answer": true
  },
  {
    "text": "Specifying the type ofstatefpis difficult in C because it is recursive and types cannotbe referenced before being fully defined.- This explains the need for an explicit type cast in the body of the while loop.",
    "code": "int main(void){int c;statefp state = start;while((c = getchar()) != EOF){state = (statefp) (*state)(c);}return 0;}",
    "answer": true
  },
  {
    "text": "Using interrupts improves task response time.",
    "code": null,
    "answer": false
  },
  {
    "text": "An interrupt service routine does not need to be allocated its own call stack.",
    "code": null,
    "answer": true
  },
  {
    "text": "A low-priority ISR can be interrupted by a high-priority task.",
    "code": null,
    "answer": false
  },
  {
    "text": "Since  disabling  interrupts  increases  interrupt  latency,  several  alternative  methods  havebeen  developed  for  dealing  with  shared  data,  including  writing  so-called  “ingeniouscode”. Thevolatilekeyword is needed to prevent the compiler from optimizing the loop away.",
    "code": "volatile static long int lSecondsToday;void interrupt vUpdateTime(){++lSecondsToday;}long lGetSeconds(){long lReturn;lReturn = lSecondsToday;while (lReturn!=lSecondsToday)lReturn = lSecondsToday;return (lReturn);}",
    "answer": true
  },
  {
    "text": "When a processor in an embedded system is powered up, interrupts are enabled to meetresponse-time requirements.",
    "code": null,
    "answer": false
  },
  {
    "text": "The shared-data problem can be solved by storing data in non-volatile memory.",
    "code": null,
    "answer": false
  },
  {
    "text": "An interrupt vector table contains the addresses of the interrupt service routines.",
    "code": null,
    "answer": true
  },
  {
    "text": "Given the following pseudo code, which reads the current values of 3 different buttonsand acts accordingly. The 3 buttons are all mapped to bits 0..2 of the button register. Thebuttons are already debounced. This code is an example of an RR architecture.",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void main (void){while (1){if (buttons & 0x01) f1();delay(1000);if (buttons & 0x02 ) f2();delay(1000);if (buttons & 0x04 ) f3();}}",
    "answer": true
  },
  {
    "text": "When none of the buttons have been pressed,  the longest time that button   2 must bepressed to activate f2() once is 1 second.",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void main (void){while (1){if (buttons & 0x01) f1();delay(1000);if (buttons & 0x02 ) f2();delay(1000);if (buttons & 0x04 ) f3();}}",
    "answer": false
  },
  {
    "text": "When the system is in an arbitrary state, button  1 must be pressed at most 8 seconds toactivate f1().",
    "code": "void f1(void){delay(1000);}void f2(void){delay(2000);}void f3(void){delay(3000);}void main (void){while (1){if (buttons & 0x01) f1();delay(1000);if (buttons & 0x02 ) f2();delay(1000);if (buttons & 0x04 ) f3();}}",
    "answer": false
  },
  {
    "text": "The worst-case latency for servicing an interrupt is a combination of factors, includingthe longest period of time in which interrupts are disabled.",
    "code": null,
    "answer": true
  },
  {
    "text": "On 8-bit processors the number of interrupt priorities is limited to 256 (28).",
    "code": null,
    "answer": false
  },
  {
    "text": "Shared (global) variables markedstaticguarantee atomic access within the code filedue to C’s data hiding principle.",
    "code": null,
    "answer": false
  },
  {
    "text": "Priority inversionoccurs when a high priority task blocks on a resource held by a lowpriority tasktthat is prevented from running due to some other task(s) with more prioritythant.",
    "code": null,
    "answer": true
  },
  {
    "text": "An RRI architecture is most robust to code changes.",
    "code": null,
    "answer": false
  },
  {
    "text": "In an RTOS, tasks can be in state BLOCKED, READY or RUNNING.- A task can transition directly from BLOCKED to READY.",
    "code": null,
    "answer": true
  },
  {
    "text": "An ISR could activate (unblock) more than one task.",
    "code": null,
    "answer": true
  },
  {
    "text": "A reentrant function maynotcall other functions",
    "code": null,
    "answer": false
  },
  {
    "text": "A  queue  inbetween  a  producer  and  consumer  task  can  be  controlled  by  a  countingsemaphore that records the number of items in the queue.",
    "code": null,
    "answer": true
  },
  {
    "text": "A program running on an RTOS may create tasks dynamically at runtime.- the program ends oncemain()and all spawned tasks have finished.",
    "code": null,
    "answer": true
  },
  {
    "text": "Even a local variable can introduce a shared data problem when its address escapes thedefining function, for example, by storing the address in a global datastructure.",
    "code": null,
    "answer": true
  },
  {
    "text": "In the implementation of theOSPend()primitive, the RTOS first switches the state ofthe current task to BLOCKED, and then looks for a task in the READY queue.- if the READY queue is empty the processor may be put into sleep mode to save energywhen idling.",
    "code": null,
    "answer": true
  },
  {
    "text": "When  using  an  RTOS  signaling  between  ISRs  and  tasks  must  be  done  by  callingappropriate RTOS primitives.",
    "code": null,
    "answer": true
  },
  {
    "text": "A function can be made reentrant by temporarily disabling interrupts, but then it may nolonger be called by an ISR.",
    "code": null,
    "answer": true
  },
  {
    "text": "The accuracy of aOSTimeDly()depends on the frequency of the periodic timer usedby the OS.- the higher the frequency, the lower the accuracy.",
    "code": null,
    "answer": false
  },
  {
    "text": "An RTOS usually provides two types of delay functions: polling-based and timer-based.- polling-based delays are specified in so-called ticks.",
    "code": null,
    "answer": false
  },
  {
    "text": "Theheartbeat timeris a single hardware timer an RTOS is using as base for all timings.",
    "code": null,
    "answer": true
  },
  {
    "text": "To address the shared-data problem, many RTOSs provide communication primitives likequeues, mailboxes, and pipes.- the unique property of a mailbox is that it can accept items from different tasks.",
    "code": null,
    "answer": false
  },
  {
    "text": "The advantage of pipes over queues is that messages/items can be of variable length.",
    "code": null,
    "answer": true
  },
  {
    "text": "With the X32 RTOS creating a task amounts to initializing a stack and invoking a contextswitch to the task’s main function.- This approach provides the possibility to use one stack for multiple (concurrent) tasksand reduce the memory footprint.",
    "code": null,
    "answer": false
  },
  {
    "text": "This code is an example of an RR architecture.\\",
    "code": "1#include<stdio.h>2#include<string.h>3#include<stdlib.h>45extern char*UART_rx_buf;// copied from <uart.h> for reference6extern char*UART_tx_buf;7extern char*UART_ier;89#defineLEN 8010static char*next_command = NULL;1112voidrx_ready() {13static charbuffer[2][LEN];14static inttoggle = 0;15static char*command = buffer[0];16static intcnt = 0;1718charc =*UART_rx_buf;19if(c == ’\\n’) {20command[cnt] = ’\\0’;21next_command = command;22toggle = 1 - toggle;23command = buffer[toggle];24cnt = 0;25}else{26command[cnt++] = c;27}28}2930intmain() {31*UART_ier |= 0x3;// start RX and TX please32while(1) {33if(next_command != NULL) {34if(strcmp(next_command, \"exit\") == 0) {35exit(0);36}else if(strcmp(next_command, \"hello\") == 0) {37printf(\"world\\n\");38}39next_command = NULL;40}41...42}43}",
    "answer": false
  },
  {
    "text": "Consider  lines  5-7  in  which  some  of  a  UART’s  registers  are  declared.    This  way  aUART, or any other peripheral for that matter, can be accessed with normal read/writeinstructions.- this mode of operation is called ’memory-mapped I/O’.",
    "code": "1#include<stdio.h>2#include<string.h>3#include<stdlib.h>45extern char*UART_rx_buf;// copied from <uart.h> for reference6extern char*UART_tx_buf;7extern char*UART_ier;89#defineLEN 8010static char*next_command = NULL;1112voidrx_ready() {13static charbuffer[2][LEN];14static inttoggle = 0;15static char*command = buffer[0];16static intcnt = 0;1718charc =*UART_rx_buf;19if(c == ’\\n’) {20command[cnt] = ’\\0’;21next_command = command;22toggle = 1 - toggle;23command = buffer[toggle];24cnt = 0;25}else{26command[cnt++] = c;27}28}2930intmain() {31*UART_ier |= 0x3;// start RX and TX please32while(1) {33if(next_command != NULL) {34if(strcmp(next_command, \"exit\") == 0) {35exit(0);36}else if(strcmp(next_command, \"hello\") == 0) {37printf(\"world\\n\");38}39next_command = NULL;40}41...42}43}",
    "answer": true
  },
  {
    "text": "The functionrxready()uses a technique called ‘alternating buffers’.- the global variablenextcommandsignals themain()routine which buffer is readyfor processing.",
    "code": "1#include<stdio.h>2#include<string.h>3#include<stdlib.h>45extern char*UART_rx_buf;// copied from <uart.h> for reference6extern char*UART_tx_buf;7extern char*UART_ier;89#defineLEN 8010static char*next_command = NULL;1112voidrx_ready() {13static charbuffer[2][LEN];14static inttoggle = 0;15static char*command = buffer[0];16static intcnt = 0;1718charc =*UART_rx_buf;19if(c == ’\\n’) {20command[cnt] = ’\\0’;21next_command = command;22toggle = 1 - toggle;23command = buffer[toggle];24cnt = 0;25}else{26command[cnt++] = c;27}28}2930intmain() {31*UART_ier |= 0x3;// start RX and TX please32while(1) {33if(next_command != NULL) {34if(strcmp(next_command, \"exit\") == 0) {35exit(0);36}else if(strcmp(next_command, \"hello\") == 0) {37printf(\"world\\n\");38}39next_command = NULL;40}41...42}43}",
    "answer": false
  },
  {
    "text": "The code suffers from a (subtle) data sharing bug as bothrxready()andmain()write to the same global variablenextcommand.- in certain casesmain()will read data beforerxready()has written it to the buffer.",
    "code": "1#include<stdio.h>2#include<string.h>3#include<stdlib.h>45extern char*UART_rx_buf;// copied from <uart.h> for reference6extern char*UART_tx_buf;7extern char*UART_ier;89#defineLEN 8010static char*next_command = NULL;1112voidrx_ready() {13static charbuffer[2][LEN];14static inttoggle = 0;15static char*command = buffer[0];16static intcnt = 0;1718charc =*UART_rx_buf;19if(c == ’\\n’) {20command[cnt] = ’\\0’;21next_command = command;22toggle = 1 - toggle;23command = buffer[toggle];24cnt = 0;25}else{26command[cnt++] = c;27}28}2930intmain() {31*UART_ier |= 0x3;// start RX and TX please32while(1) {33if(next_command != NULL) {34if(strcmp(next_command, \"exit\") == 0) {35exit(0);36}else if(strcmp(next_command, \"hello\") == 0) {37printf(\"world\\n\");38}39next_command = NULL;40}41...42}43}",
    "answer": false
  },
  {
    "text": "Removing the write statement on line 39 will not resolve the shared data bug.-  insteadmain()should  clear  the  command  by  writing  a  null  character  to  the  firstposition in the buffer (nextcommand[0] = 0;).",
    "code": "1#include<stdio.h>2#include<string.h>3#include<stdlib.h>45extern char*UART_rx_buf;// copied from <uart.h> for reference6extern char*UART_tx_buf;7extern char*UART_ier;89#defineLEN 8010static char*next_command = NULL;1112voidrx_ready() {13static charbuffer[2][LEN];14static inttoggle = 0;15static char*command = buffer[0];16static intcnt = 0;1718charc =*UART_rx_buf;19if(c == ’\\n’) {20command[cnt] = ’\\0’;21next_command = command;22toggle = 1 - toggle;23command = buffer[toggle];24cnt = 0;25}else{26command[cnt++] = c;27}28}2930intmain() {31*UART_ier |= 0x3;// start RX and TX please32while(1) {33if(next_command != NULL) {34if(strcmp(next_command, \"exit\") == 0) {35exit(0);36}else if(strcmp(next_command, \"hello\") == 0) {37printf(\"world\\n\");38}39next_command = NULL;40}41...42}43}",
    "answer": false
  },
  {
    "text": "An alternative approach would be to make use of semaphores to supportrxready()passing the next command tomain().- two semaphores are required; one for signalling and the other for mutual exclusive accessto the buffers.",
    "code": "1#include<stdio.h>2#include<string.h>3#include<stdlib.h>45extern char*UART_rx_buf;// copied from <uart.h> for reference6extern char*UART_tx_buf;7extern char*UART_ier;89#defineLEN 8010static char*next_command = NULL;1112voidrx_ready() {13static charbuffer[2][LEN];14static inttoggle = 0;15static char*command = buffer[0];16static intcnt = 0;1718charc =*UART_rx_buf;19if(c == ’\\n’) {20command[cnt] = ’\\0’;21next_command = command;22toggle = 1 - toggle;23command = buffer[toggle];24cnt = 0;25}else{26command[cnt++] = c;27}28}2930intmain() {31*UART_ier |= 0x3;// start RX and TX please32while(1) {33if(next_command != NULL) {34if(strcmp(next_command, \"exit\") == 0) {35exit(0);36}else if(strcmp(next_command, \"hello\") == 0) {37printf(\"world\\n\");38}39next_command = NULL;40}41...42}43}",
    "answer": false
  },
  {
    "text": "Tasks  in  an  RTOS  are  often  structured  as  state  machines  with  states  stored  in  privatevariables and ISRs advancing the state machine.",
    "code": null,
    "answer": false
  },
  {
    "text": "In an RTOS each task requires its own stack space.",
    "code": null,
    "answer": true
  },
  {
    "text": "Printing from an ISR is considered bad practice as the driver resides in the RTOS.",
    "code": null,
    "answer": false
  },
  {
    "text": "Time-slicing should be avoided in an RTOS because it introduces the shared-data problem.",
    "code": null,
    "answer": false
  },
  {
    "text": "A semaphore S used by task A must be declared as a local variable within the source codeof A.",
    "code": null,
    "answer": false
  },
  {
    "text": "Time  slicing  between  tasks  of  equal  priority  is  to  be  avoided  as  it  compromises  thepredictability of their response times.",
    "code": null,
    "answer": true
  },
  {
    "text": "When developing code for an embedded system, the software can de structured into HW-dependent and HW-independent code.- Doing so makes debugging HW-independent code feasible on the host platform",
    "code": null,
    "answer": true
  },
  {
    "text": "An in-circuit emulator is preferred to a logic analyzer because it can be used with any typeof processor.",
    "code": null,
    "answer": false
  },
  {
    "text": "Although the assert macro is a useful debugging aid during program development, it canonly be used on the target machine.",
    "code": null,
    "answer": false
  },
  {
    "text": "A large study of outdoor sensor-network deployments [Beutel:2009] has shown that thetwo most underestimated problems have been the water-proof packaging of the sensornodes and the provision of a reliable base station.",
    "code": null,
    "answer": true
  },
  {
    "text": "When debugging code for a distributed sensor network, collecting the (debug) output ofthe nodes can be arranged in different ways.- A major advantage of a testbed is that large volumes of (debug) data can be handled.",
    "code": null,
    "answer": true
  }
]

